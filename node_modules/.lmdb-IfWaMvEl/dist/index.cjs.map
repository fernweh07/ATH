{"version":3,"file":"index.cjs","sources":["../native.js","../util/when.js","../write.js","../util/RangeIterable.js","../keys.js","../level.js","../index.js","../read.js","../caching.js","../open.js","../node-index.js"],"sourcesContent":["import { dirname, join, default as pathModule } from 'path';\nimport { fileURLToPath } from 'url';\nimport loadNAPI from 'node-gyp-build-optional-packages';\nexport let Env, Txn, Dbi, Compression, Cursor, getAddress, getBufferAddress, createBufferForAddress, clearKeptObjects, globalBuffer, setGlobalBuffer, arch, fs, os, onExit, tmpdir, lmdbError, path, EventEmitter, orderedBinary, MsgpackrEncoder, WeakLRUCache, setEnvMap, getEnvMap, getByBinary, detachBuffer, startRead, setReadCallback, write, position, iterate, prefetch, resetTxn, getCurrentValue, getCurrentShared, getStringByBinary, getSharedByBinary, getSharedBuffer, compress;\n\npath = pathModule;\nlet dirName = (typeof __dirname == 'string' ? __dirname : // for bun, which doesn't have fileURLToPath\n\tdirname(fileURLToPath(import.meta.url))).replace(/dist$/, ''); // for node, which doesn't have __dirname in ESM\nexport let nativeAddon = loadNAPI(dirName);\n\nif (process.isBun && false) {\n\tconst { linkSymbols, FFIType } = require('bun:ffi');\n\tlet lmdbLib = linkSymbols({\n\t\tgetByBinary: {\n\t\t\targs: [FFIType.f64, FFIType.u32],\n\t\t\treturns: FFIType.u32,\n\t\t\tptr: nativeAddon.getByBinaryPtr\n\t\t},\n\t\titerate: {\n\t\t\targs: [FFIType.f64],\n\t\t\treturns: FFIType.i32,\n\t\t\tptr: nativeAddon.iteratePtr,\n\t\t},\n\t\tposition: {\n\t\t\targs: [FFIType.f64, FFIType.u32, FFIType.u32, FFIType.u32, FFIType.f64],\n\t\t\treturns: FFIType.i32,\n\t\t\tptr: nativeAddon.positionPtr,\n\t\t},\n\t\twrite: {\n\t\t\targs: [FFIType.f64, FFIType.f64],\n\t\t\treturns: FFIType.i32,\n\t\t\tptr: nativeAddon.writePtr,\n\t\t},\n\t\tresetTxn: {\n\t\t\targs: [FFIType.f64],\n\t\t\treturns: FFIType.void,\n\t\t\tptr: nativeAddon.resetTxnPtr,\n\t\t}\n\t});\n\tfor (let key in lmdbLib.symbols) {\n\t\tnativeAddon[key] = lmdbLib.symbols[key].native;\n\t}\n}\nsetNativeFunctions(nativeAddon);\n\t\nexport function setNativeFunctions(externals) {\n\tEnv = externals.Env;\n\tTxn = externals.Txn;\n\tDbi = externals.Dbi;\n\tCompression = externals.Compression;\n\tgetAddress = externals.getAddress;\n\tgetBufferAddress = externals.getBufferAddress;\n\tcreateBufferForAddress = externals.createBufferForAddress;\n\tclearKeptObjects = externals.clearKeptObjects || function() {};\n\tgetByBinary = externals.getByBinary;\n\tdetachBuffer  = externals.detachBuffer;\n\tstartRead = externals.startRead;\n\tsetReadCallback = externals.setReadCallback;\n\tsetGlobalBuffer = externals.setGlobalBuffer;\n\tglobalBuffer = externals.globalBuffer;\n\tgetSharedBuffer = externals.getSharedBuffer;\n\tprefetch = externals.prefetch;\n\titerate = externals.iterate;\n\tposition = externals.position;\n\tresetTxn = externals.resetTxn;\n\tgetCurrentValue = externals.getCurrentValue;\n\tgetCurrentShared = externals.getCurrentShared;\n\tgetStringByBinary = externals.getStringByBinary;\n\tgetSharedByBinary = externals.getSharedByBinary;\n\twrite = externals.write;\n\tcompress = externals.compress;\n\tCursor = externals.Cursor;\n\tlmdbError = externals.lmdbError;\n\tif (externals.tmpdir)\n        tmpdir = externals.tmpdir\n}\nexport function setExternals(externals) {\n\tarch = externals.arch;\n\tfs = externals.fs;\n\tEventEmitter = externals.EventEmitter;\n\torderedBinary = externals.orderedBinary;\n\tMsgpackrEncoder = externals.MsgpackrEncoder;\n\tWeakLRUCache = externals.WeakLRUCache;\n\ttmpdir = externals.tmpdir;\n   os = externals.os;\n\tonExit = externals.onExit;\n}\n","export function when(promise, callback, errback) {\n  if (promise && promise.then) {\n    return errback ?\n      promise.then(callback, errback) :\n      promise.then(callback);\n  }\n  return callback(promise);\n}\n","import { getAddress, getBufferAddress, write, compress, lmdbError } from './native.js';\nimport { when } from './util/when.js';\nvar backpressureArray;\n\nconst WAITING_OPERATION = 0x2000000;\nconst BACKPRESSURE_THRESHOLD = 100000;\nconst TXN_DELIMITER = 0x8000000;\nconst TXN_COMMITTED = 0x10000000;\nconst TXN_FLUSHED = 0x20000000;\nconst TXN_FAILED = 0x40000000;\nexport const FAILED_CONDITION = 0x4000000;\nconst REUSE_BUFFER_MODE = 512;\nconst RESET_BUFFER_MODE = 1024;\nconst NO_RESOLVE = 16;\nconst HAS_TXN = 8;\nconst CONDITIONAL_VERSION_LESS_THAN = 0x800;\nconst CONDITIONAL_ALLOW_NOTFOUND = 0x800;\n\nconst SYNC_PROMISE_SUCCESS = Promise.resolve(true);\nconst SYNC_PROMISE_FAIL = Promise.resolve(false);\nSYNC_PROMISE_SUCCESS.isSync = true;\nSYNC_PROMISE_FAIL.isSync = true;\nconst PROMISE_SUCCESS = Promise.resolve(true);\nexport const ABORT = 4.452694326329068e-106; // random/unguessable numbers, which work across module/versions and native\nexport const IF_EXISTS = 3.542694326329068e-103;\nconst CALLBACK_THREW = {};\nconst LocalSharedArrayBuffer = typeof Deno != 'undefined' ? ArrayBuffer : SharedArrayBuffer; // Deno can't handle SharedArrayBuffer as an FFI argument due to https://github.com/denoland/deno/issues/12678\nconst ByteArray = typeof Buffer != 'undefined' ? function(buffer) { return Buffer.from(buffer) } : Uint8Array;\nconst queueTask = typeof setImmediate != 'undefined' ? setImmediate : setTimeout; // TODO: Or queueMicrotask?\n//let debugLog = []\nconst WRITE_BUFFER_SIZE = 0x10000;\nvar log = [];\nexport function addWriteMethods(LMDBStore, { env, fixedBuffer, resetReadTxn, useWritemap, maxKeySize,\n\teventTurnBatching, txnStartThreshold, batchStartThreshold, overlappingSync, commitDelay, separateFlushed, maxFlushDelay }) {\n\t//  stands for write instructions\n\tvar dynamicBytes;\n\tfunction allocateInstructionBuffer() {\n\t\t// Must use a shared buffer on older node in order to use Atomics, and it is also more correct since we are \n\t\t// indeed accessing and modifying it from another thread (in C). However, Deno can't handle it for\n\t\t// FFI so aliased above\n\t\tlet buffer = new LocalSharedArrayBuffer(WRITE_BUFFER_SIZE);\n\t\tdynamicBytes = new ByteArray(buffer);\n\t\tlet uint32 = dynamicBytes.uint32 = new Uint32Array(buffer, 0, WRITE_BUFFER_SIZE >> 2);\n\t\tuint32[2] = 0;\n\t\tdynamicBytes.float64 = new Float64Array(buffer, 0, WRITE_BUFFER_SIZE >> 3);\n\t\tbuffer.address = getBufferAddress(dynamicBytes);\n\t\tuint32.address = buffer.address + uint32.byteOffset;\n\t\tdynamicBytes.position = 1; // we start at position 1 to save space for writing the txn id before the txn delimiter\n\t\treturn dynamicBytes;\n\t}\n\tvar newBufferThreshold = (WRITE_BUFFER_SIZE - maxKeySize - 64) >> 3; // need to reserve more room if we do inline values\n\tvar outstandingWriteCount = 0;\n\tvar startAddress = 0;\n\tvar writeTxn = null;\n\tvar committed;\n\tvar abortedNonChildTransactionWarn;\n\tvar nextTxnCallbacks = [];\n\tvar commitPromise, flushPromise, flushResolvers = [], batchFlushResolvers = [];\n\tcommitDelay = commitDelay || 0;\n\teventTurnBatching = eventTurnBatching === false ? false : true;\n\tvar enqueuedCommit;\n\tvar afterCommitCallbacks = [];\n\tvar beforeCommitCallbacks = [];\n\tvar enqueuedEventTurnBatch;\n\tvar batchDepth = 0;\n\tvar lastWritePromise;\n\tvar writeBatchStart, outstandingBatchCount, lastSyncTxnFlush, lastFlushTimeout, lastFlushCallback;\n\tvar hasUnresolvedTxns;\n\ttxnStartThreshold = txnStartThreshold || 5;\n\tbatchStartThreshold = batchStartThreshold || 1000;\n\tmaxFlushDelay = maxFlushDelay || 500;\n\n\tallocateInstructionBuffer();\n\tdynamicBytes.uint32[2] = TXN_DELIMITER | TXN_COMMITTED | TXN_FLUSHED;\n\tvar txnResolution, nextResolution = {\n\t\tuint32: dynamicBytes.uint32, flagPosition: 2, flag: 0, valueBuffer: null, next: null, meta: null };\n\tvar uncommittedResolution = {\n\t\tuint32: null, flagPosition: 2, flag: 0, valueBuffer: null, next: nextResolution, meta: null };\n\tvar unwrittenResolution = nextResolution;\n\tvar lastPromisedResolution = uncommittedResolution;\n\tvar lastQueuedResolution = uncommittedResolution;\n\tfunction writeInstructions(flags, store, key, value, version, ifVersion) {\n\t\tlet writeStatus;\n\t\tlet targetBytes, position, encoder;\n\t\tlet valueSize, valueBuffer, valueBufferStart;\n\t\tif (flags & 2) {\n\t\t\t// encode first in case we have to write a shared structure\n\t\t\tencoder = store.encoder;\n\t\t\tif (value && value['\\x10binary-data\\x02'])\n\t\t\t\tvalueBuffer = value['\\x10binary-data\\x02'];\n\t\t\telse if (encoder) {\n\t\t\t\tif (encoder.copyBuffers) // use this as indicator for support buffer reuse for now\n\t\t\t\t\tvalueBuffer = encoder.encode(value, REUSE_BUFFER_MODE | (writeTxn ? RESET_BUFFER_MODE : 0)); // in addition, if we are writing sync, after using, we can immediately reset the encoder's position to reuse that space, which can improve performance\n\t\t\t\telse { // various other encoders, including JSON.stringify, that might serialize to a string\n\t\t\t\t\tvalueBuffer = encoder.encode(value);\n\t\t\t\t\tif (typeof valueBuffer == 'string')\n\t\t\t\t\t\tvalueBuffer = Buffer.from(valueBuffer); // TODO: Would be nice to write strings inline in the instructions\n\t\t\t\t}\n\t\t\t} else if (typeof value == 'string') {\n\t\t\t\tvalueBuffer = Buffer.from(value); // TODO: Would be nice to write strings inline in the instructions\n\t\t\t} else if (value instanceof Uint8Array)\n\t\t\t\tvalueBuffer = value;\n\t\t\telse\n\t\t\t\tthrow new Error('Invalid value to put in database ' + value + ' (' + (typeof value) +'), consider using encoder');\n\t\t\tvalueBufferStart = valueBuffer.start;\n\t\t\tif (valueBufferStart > -1) // if we have buffers with start/end position\n\t\t\t\tvalueSize = valueBuffer.end - valueBufferStart; // size\n\t\t\telse\n\t\t\t\tvalueSize = valueBuffer.length;\n\t\t\tif (store.dupSort && valueSize > maxKeySize)\n\t\t\t\tthrow new Error('The value is larger than the maximum size (' + maxKeySize + ') for a value in a dupSort database');\n\t\t} else\n\t\t\tvalueSize = 0;\n\t\tif (writeTxn) {\n\t\t\ttargetBytes = fixedBuffer;\n\t\t\tposition = 0;\n\t\t} else {\n\t\t\tif (eventTurnBatching && !enqueuedEventTurnBatch && batchDepth == 0) {\n\t\t\t\tenqueuedEventTurnBatch = queueTask(() => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor (let i = 0, l = beforeCommitCallbacks.length; i < l; i++) {\n\t\t\t\t\t\t\tbeforeCommitCallbacks[i]();\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(error) {\n\t\t\t\t\t\tconsole.error(error);\n\t\t\t\t\t}\n\t\t\t\t\tenqueuedEventTurnBatch = null;\n\t\t\t\t\tbatchDepth--;\n\t\t\t\t\tfinishBatch();\n\t\t\t\t\tif (writeBatchStart)\n\t\t\t\t\t\twriteBatchStart(); // TODO: When we support delay start of batch, optionally don't delay this\n\t\t\t\t});\n\t\t\t\tcommitPromise = null; // reset the commit promise, can't know if it is really a new transaction prior to finishWrite being called\n\t\t\t\tflushPromise = null;\n\t\t\t\twriteBatchStart = writeInstructions(1, store);\n\t\t\t\toutstandingBatchCount = 0;\n\t\t\t\tbatchDepth++;\n\t\t\t}\n\t\t\ttargetBytes = dynamicBytes;\n\t\t\tposition = targetBytes.position;\n\t\t}\n\t\tlet uint32 = targetBytes.uint32, float64 = targetBytes.float64;\n\t\tlet flagPosition = position << 1; // flagPosition is the 32-bit word starting position\n\n\t\t// don't increment position until we are sure we don't have any key writing errors\n\t\tif (!uint32) {\n\t\t\tthrow new Error('Internal buffers have been corrupted');\n\t\t}\n\t\tuint32[flagPosition + 1] = store.db.dbi;\n\t\tif (flags & 4) {\n\t\t\tlet keyStartPosition = (position << 3) + 12;\n\t\t\tlet endPosition;\n\t\t\ttry {\n\t\t\t\tendPosition = store.writeKey(key, targetBytes, keyStartPosition);\n\t\t\t\tif (!(keyStartPosition < endPosition) && (flags & 0xf) != 12)\n\t\t\t\t\tthrow new Error('Invalid key or zero length key is not allowed in LMDB ' + key)\n\t\t\t} catch(error) {\n\t\t\t\ttargetBytes.fill(0, keyStartPosition);\n\t\t\t\tif (error.name == 'RangeError')\n\t\t\t\t\terror = new Error('Key size is larger than the maximum key size (' + maxKeySize + ')');\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tlet keySize = endPosition - keyStartPosition;\n\t\t\tif (keySize > maxKeySize) {\n\t\t\t\ttargetBytes.fill(0, keyStartPosition); // restore zeros\n\t\t\t\tthrow new Error('Key size is larger than the maximum key size (' + maxKeySize + ')');\n\t\t\t}\n\t\t\tuint32[flagPosition + 2] = keySize;\n\t\t\tposition = (endPosition + 16) >> 3;\n\t\t\tif (flags & 2) {\n\t\t\t\tlet mustCompress;\n\t\t\t\tif (valueBufferStart > -1) { // if we have buffers with start/end position\n\t\t\t\t\t// record pointer to value buffer\n\t\t\t\t\tfloat64[position] = (valueBuffer.address ||\n\t\t\t\t\t\t(valueBuffer.address = getAddress(valueBuffer.buffer))) + valueBufferStart;\n\t\t\t\t\tmustCompress = valueBuffer[valueBufferStart] >= 250; // this is the compression indicator, so we must compress\n\t\t\t\t} else {\n\t\t\t\t\tlet valueArrayBuffer = valueBuffer.buffer;\n\t\t\t\t\t// record pointer to value buffer\n\t\t\t\t\tlet address = (valueArrayBuffer.address ||\n\t\t\t\t\t\t(valueBuffer.length === 0 ? 0 : // externally allocated buffers of zero-length with the same non-null-pointer can crash node, #161\n\t\t\t\t\t\tvalueArrayBuffer.address = getAddress(valueArrayBuffer)))\n\t\t\t\t\t\t\t+ valueBuffer.byteOffset;\n\t\t\t\t\tif (address <= 0 && valueBuffer.length > 0)\n\t\t\t\t\t\tconsole.error('Supplied buffer had an invalid address', address);\n\t\t\t\t\tfloat64[position] = address;\n\t\t\t\t\tmustCompress = valueBuffer[0] >= 250; // this is the compression indicator, so we must compress\n\t\t\t\t}\n\t\t\t\tuint32[(position++ << 1) - 1] = valueSize;\n\t\t\t\tif (store.compression && (valueSize >= store.compression.threshold || mustCompress)) {\n\t\t\t\t\tflags |= 0x100000;\n\t\t\t\t\tfloat64[position] = store.compression.address;\n\t\t\t\t\tif (!writeTxn)\n\t\t\t\t\t\tcompress(env.address, uint32.address + (position << 3), () => {\n\t\t\t\t\t\t\t// this is never actually called in NodeJS, just use to pin the buffer in memory until it is finished\n\t\t\t\t\t\t\t// and is a no-op in Deno\n\t\t\t\t\t\t\tif (!float64)\n\t\t\t\t\t\t\t\tthrow new Error('No float64 available');\n\t\t\t\t\t\t});\n\t\t\t\t\tposition++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ifVersion !== undefined) {\n\t\t\t\tif (ifVersion === null)\n\t\t\t\t\tflags |= 0x10; // if it does not exist, MDB_NOOVERWRITE\n\t\t\t\telse {\n\t\t\t\t\tflags |= 0x100;\n\t\t\t\t\tfloat64[position++] = ifVersion;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (version !== undefined) {\n\t\t\t\tflags |= 0x200;\n\t\t\t\tfloat64[position++] = version || 0;\n\t\t\t}\n\t\t} else\n\t\t\tposition++;\n\t\ttargetBytes.position = position;\n\t\tif (writeTxn) {\n\t\t\tuint32[0] = flags;\n\t\t\twrite(env.address, uint32.address);\n\t\t\treturn () => (uint32[0] & FAILED_CONDITION) ? SYNC_PROMISE_FAIL : SYNC_PROMISE_SUCCESS;\n\t\t}\n\t\t// if we ever use buffers that haven't been zero'ed, need to clear out the next slot like this:\n\t\t// uint32[position << 1] = 0 // clear out the next slot\n\t\tlet nextUint32;\n\t\tif (position > newBufferThreshold) {\n\t\t\t// make new buffer and make pointer to it\n\t\t\tlet lastPosition = position;\n\t\t\ttargetBytes = allocateInstructionBuffer();\n\t\t\tposition = targetBytes.position;\n\t\t\tfloat64[lastPosition + 1] = targetBytes.uint32.address + (position << 3);\n\t\t\tuint32[lastPosition << 1] = 3; // pointer instruction\n\t\t\tnextUint32 = targetBytes.uint32;\n\t\t} else\n\t\t\tnextUint32 = uint32;\n\t\tlet resolution = nextResolution;\n\t\t// create the placeholder next resolution\n\t\tnextResolution = resolution.next = { // we try keep resolutions exactly the same object type\n\t\t\tuint32: nextUint32,\n\t\t\tflagPosition: position << 1,\n\t\t\tflag: 0, // TODO: eventually eliminate this, as we can probably signify HAS_TXN/NO_RESOLVE/FAILED_CONDITION in upper bits\n\t\t\tvalueBuffer: fixedBuffer, // these are all just placeholders so that we have the right hidden class initially allocated\n\t\t\tnext: null,\n\t\t\tmeta: null,\n\t\t};\n\t\tlastQueuedResolution = resolution;\n\n\t\tlet writtenBatchDepth = batchDepth;\n\n\t\treturn (callback) => {\n\t\t\tif (writtenBatchDepth) {\n\t\t\t\t// if we are in a batch, the transaction can't close, so we do the faster,\n\t\t\t\t// but non-deterministic updates, knowing that the write thread can\n\t\t\t\t// just poll for the status change if we miss a status update\n\t\t\t\twriteStatus = uint32[flagPosition];\n\t\t\t\tuint32[flagPosition] = flags;\n\t\t\t\t//writeStatus = Atomics.or(uint32, flagPosition, flags)\n\t\t\t\tif (writeBatchStart && !writeStatus) {\n\t\t\t\t\toutstandingBatchCount += 1 + (valueSize >> 12);\n\t\t\t\t\tif (outstandingBatchCount > batchStartThreshold) {\n\t\t\t\t\t\toutstandingBatchCount = 0;\n\t\t\t\t\t\twriteBatchStart();\n\t\t\t\t\t\twriteBatchStart = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else // otherwise the transaction could end at any time and we need to know the\n\t\t\t\t// deterministically if it is ending, so we can reset the commit promise\n\t\t\t\t// so we use the slower atomic operation\n\t\t\t\twriteStatus = Atomics.or(uint32, flagPosition, flags);\n\t\n\t\t\toutstandingWriteCount++;\n\t\t\tif (writeStatus & TXN_DELIMITER) {\n\t\t\t\tcommitPromise = null; // TODO: Don't reset these if this comes from the batch start operation on an event turn batch\n\t\t\t\tflushPromise = null;\n\t\t\t\tflushResolvers = [];\n\t\t\t\tqueueCommitResolution(resolution);\n\t\t\t\tif (!startAddress) {\n\t\t\t\t\tstartAddress = uint32.address + (flagPosition << 2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!writtenBatchDepth && batchFlushResolvers.length > 0) {\n\t\t\t\tflushResolvers.push(...batchFlushResolvers);\n\t\t\t\tbatchFlushResolvers = [];\n\t\t\t}\n\t\t\tif (!flushPromise && overlappingSync) {\n\t\t\t\tflushPromise = new Promise(resolve => {\n\t\t\t\t\tif (writtenBatchDepth) {\n\t\t\t\t\t\tbatchFlushResolvers.push(resolve);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflushResolvers.push(resolve);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (writeStatus & WAITING_OPERATION) { // write thread is waiting\n\t\t\t\twrite(env.address, 0);\n\t\t\t}\n\t\t\tif (outstandingWriteCount > BACKPRESSURE_THRESHOLD && !writeBatchStart) {\n\t\t\t\tif (!backpressureArray)\n\t\t\t\t\tbackpressureArray = new Int32Array(new SharedArrayBuffer(4), 0, 1);\n\t\t\t\tAtomics.wait(backpressureArray, 0, 0, Math.round(outstandingWriteCount / BACKPRESSURE_THRESHOLD));\n\t\t\t}\n\t\t\tif (startAddress) {\n\t\t\t\tif (eventTurnBatching)\n\t\t\t\t\tstartWriting(); // start writing immediately because this has already been batched/queued\n\t\t\t\telse if (!enqueuedCommit && txnStartThreshold) {\n\t\t\t\t\tenqueuedCommit = (commitDelay == 0 && typeof setImmediate != 'undefined') ? setImmediate(() => startWriting()) : setTimeout(() => startWriting(), commitDelay);\n\t\t\t\t} else if (outstandingWriteCount > txnStartThreshold)\n\t\t\t\t\tstartWriting();\n\t\t\t}\n\n\t\t\tif ((outstandingWriteCount & 7) === 0)\n\t\t\t\tresolveWrites();\n\t\t\t\n\t\t\tif (store.cache) {\n\t\t\t\tresolution.meta = {\n\t\t\t\t\tkey,\n\t\t\t\t\tstore,\n\t\t\t\t\tvalueSize: valueBuffer ? valueBuffer.length : 0,\n\t\t\t\t};\n\t\t\t}\n\t\t\tresolution.valueBuffer = valueBuffer;\n\n\t\t\tif (callback) {\n\t\t\t\tif (callback === IF_EXISTS)\n\t\t\t\t\tifVersion = IF_EXISTS;\n\t\t\t\telse {\n\t\t\t\t\tlet meta = resolution.meta || (resolution.meta = {});\n\t\t\t\t\tmeta.reject = callback;\n\t\t\t\t\tmeta.resolve = (value) => callback(null, value);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ifVersion === undefined) {\n\t\t\t\tif (writtenBatchDepth > 1) {\n\t\t\t\t\tif (!resolution.flag && !store.cache)\n\t\t\t\t\t\tresolution.flag = NO_RESOLVE;\n\t\t\t\t\treturn PROMISE_SUCCESS; // or return undefined?\n\t\t\t\t}\n\t\t\t\tif (commitPromise) {\n\t\t\t\t\tif (!resolution.flag)\n\t\t\t\t\t\tresolution.flag = NO_RESOLVE;\n\t\t\t\t} else {\n\t\t\t\t\tcommitPromise = new Promise((resolve, reject) => {\n\t\t\t\t\t\tlet meta = resolution.meta || (resolution.meta = {});\n\t\t\t\t\t\tmeta.resolve = resolve;\n\t\t\t\t\t\tresolve.unconditional = true;\n\t\t\t\t\t\tmeta.reject = reject;\n\t\t\t\t\t});\n\t\t\t\t\tif (separateFlushed)\n\t\t\t\t\t\tcommitPromise.flushed = overlappingSync ? flushPromise : commitPromise;\n\t\t\t\t}\n\t\t\t\treturn commitPromise;\n\t\t\t}\n\t\t\tlastWritePromise = new Promise((resolve, reject) => {\n\t\t\t\tlet meta = resolution.meta || (resolution.meta = {});\n\t\t\t\tmeta.resolve = resolve;\n\t\t\t\tmeta.reject = reject;\n\t\t\t});\n\t\t\tif (separateFlushed)\n\t\t\t\tlastWritePromise.flushed = overlappingSync ? flushPromise : lastWritePromise;\n\t\t\treturn lastWritePromise;\n\t\t};\n\t}\n\tlet committedFlushResolvers, lastSync = Promise.resolve()\n\tfunction startWriting() {\n\t\tif (enqueuedCommit) {\n\t\t\tclearImmediate(enqueuedCommit);\n\t\t\tenqueuedCommit = null;\n\t\t}\n\t\tlet resolvers = flushResolvers;\n\t\tlet start = Date.now();\n\t\tenv.startWriting(startAddress, (status) => {\n\t\t\tif (dynamicBytes.uint32[dynamicBytes.position << 1] & TXN_DELIMITER)\n\t\t\t\tqueueCommitResolution(nextResolution);\n\n\t\t\tresolveWrites(true);\n\t\t\tswitch (status) {\n\t\t\t\tcase 0:\n\t\t\t\t\tfor (let resolver of resolvers) {\n\t\t\t\t\t\tresolver();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\thasUnresolvedTxns = false;\n\t\t\t\t\texecuteTxnCallbacks();\n\t\t\t\t\treturn hasUnresolvedTxns;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlmdbError(status);\n\t\t\t\t\t} catch(error) {\n\t\t\t\t\t\tconsole.error(error);\n\t\t\t\t\t\tif (commitRejectPromise) {\n\t\t\t\t\t\t\tcommitRejectPromise.reject(error);\n\t\t\t\t\t\t\tcommitRejectPromise = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tstartAddress = 0;\n\t}\n\n\tfunction queueCommitResolution(resolution) {\n\t\tif (!(resolution.flag & HAS_TXN)) {\n\t\t\tresolution.flag = HAS_TXN;\n\t\t\tif (txnResolution) {\n\t\t\t\ttxnResolution.nextTxn = resolution;\n\t\t\t\t//outstandingWriteCount = 0\n\t\t\t}\n\t\t\telse\n\t\t\t\ttxnResolution = resolution;\n\t\t}\n\t}\n\tvar TXN_DONE = TXN_COMMITTED | TXN_FAILED;\n\tfunction resolveWrites(async) {\n\t\t// clean up finished instructions\n\t\tlet instructionStatus;\n\t\twhile ((instructionStatus = unwrittenResolution.uint32[unwrittenResolution.flagPosition])\n\t\t\t\t& 0x1000000) {\n\t\t\tif (unwrittenResolution.callbacks) {\n\t\t\t\tnextTxnCallbacks.push(unwrittenResolution.callbacks);\n\t\t\t\tunwrittenResolution.callbacks = null;\n\t\t\t}\n\t\t\toutstandingWriteCount--;\n\t\t\tif (unwrittenResolution.flag !== HAS_TXN) {\n\t\t\t\tif (unwrittenResolution.flag === NO_RESOLVE && !unwrittenResolution.store) {\n\t\t\t\t\t// in this case we can completely remove from the linked list, clearing more memory\n\t\t\t\t\tlastPromisedResolution.next = unwrittenResolution = unwrittenResolution.next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tunwrittenResolution.uint32 = null;\n\t\t\t}\n\t\t\tunwrittenResolution.valueBuffer = null;\n\t\t\tunwrittenResolution.flag = instructionStatus;\n\t\t\tlastPromisedResolution = unwrittenResolution;\n\t\t\tunwrittenResolution = unwrittenResolution.next;\n\t\t}\n\t\twhile (txnResolution &&\n\t\t\t(instructionStatus = txnResolution.uint32[txnResolution.flagPosition] & TXN_DONE)) {\n\t\t\tif (instructionStatus & TXN_FAILED)\n\t\t\t\trejectCommit();\n\t\t\telse\n\t\t\t\tresolveCommit(async);\n\t\t}\n\t}\n\n\tfunction resolveCommit(async) {\n\t\tafterCommit(txnResolution.uint32[txnResolution.flagPosition - 1]);\n\t\tif (async)\n\t\t\tresetReadTxn();\n\t\telse\n\t\t\tqueueMicrotask(resetReadTxn); // TODO: only do this if there are actually committed writes?\n\t\tdo {\n\t\t\tif (uncommittedResolution.meta && uncommittedResolution.meta.resolve) {\n\t\t\t\tlet resolve = uncommittedResolution.meta.resolve;\n\t\t\t\tif (uncommittedResolution.flag & FAILED_CONDITION && !resolve.unconditional)\n\t\t\t\t\tresolve(false);\n\t\t\t\telse\n\t\t\t\t\tresolve(true);\n\t\t\t}\n\t\t} while((uncommittedResolution = uncommittedResolution.next) && uncommittedResolution != txnResolution)\n\t\ttxnResolution = txnResolution.nextTxn;\n\t}\n\tvar commitRejectPromise;\n\tfunction rejectCommit() {\n\t\tafterCommit();\n\t\tif (!commitRejectPromise) {\n\t\t\tlet rejectFunction;\n\t\t\tcommitRejectPromise = new Promise((resolve, reject) => rejectFunction = reject);\n\t\t\tcommitRejectPromise.reject = rejectFunction;\n\t\t}\n\t\tdo {\n\t\t\tif (uncommittedResolution.meta && uncommittedResolution.meta.reject) {\n\t\t\t\tlet flag = uncommittedResolution.flag & 0xf;\n\t\t\t\tlet error = new Error(\"Commit failed (see commitError for details)\");\n\t\t\t\terror.commitError = commitRejectPromise;\n\t\t\t\tuncommittedResolution.meta.reject(error);\n\t\t\t}\n\t\t} while((uncommittedResolution = uncommittedResolution.next) && uncommittedResolution != txnResolution)\n\t\ttxnResolution = txnResolution.nextTxn;\n\t}\n\tfunction atomicStatus(uint32, flagPosition, newStatus) {\n\t\tif (batchDepth) {\n\t\t\t// if we are in a batch, the transaction can't close, so we do the faster,\n\t\t\t// but non-deterministic updates, knowing that the write thread can\n\t\t\t// just poll for the status change if we miss a status update\n\t\t\tlet writeStatus = uint32[flagPosition];\n\t\t\tuint32[flagPosition] = newStatus;\n\t\t\treturn writeStatus;\n\t\t\t//return Atomics.or(uint32, flagPosition, newStatus)\n\t\t} else // otherwise the transaction could end at any time and we need to know the\n\t\t\t// deterministically if it is ending, so we can reset the commit promise\n\t\t\t// so we use the slower atomic operation\n\t\t\treturn Atomics.or(uint32, flagPosition, newStatus);\n\t}\n\tfunction afterCommit(txnId) {\n\t\tfor (let i = 0, l = afterCommitCallbacks.length; i < l; i++) {\n\t\t\tafterCommitCallbacks[i]({ next: uncommittedResolution, last: unwrittenResolution, txnId });\n\t\t}\n\t}\n\tasync function executeTxnCallbacks() {\n\t\tenv.writeTxn = writeTxn = { write: true };\n\t\tnextTxnCallbacks.isExecuting = true;\n\t\tfor (let i = 0; i < nextTxnCallbacks.length; i++) {\n\t\t\tlet txnCallbacks = nextTxnCallbacks[i];\n\t\t\tfor (let j = 0, l = txnCallbacks.length; j < l; j++) {\n\t\t\t\tlet userTxnCallback = txnCallbacks[j];\n\t\t\t\tlet asChild = userTxnCallback.asChild;\n\t\t\t\tif (asChild) {\n\t\t\t\t\tenv.beginTxn(1); // abortable\n\t\t\t\t\tlet parentTxn = writeTxn;\n\t\t\t\t\tenv.writeTxn = writeTxn = { write: true };\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet result = userTxnCallback.callback();\n\t\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\t\thasUnresolvedTxns = true;\n\t\t\t\t\t\t\tawait result;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (result === ABORT)\n\t\t\t\t\t\t\tenv.abortTxn();\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tenv.commitTxn();\n\t\t\t\t\t\tclearWriteTxn(parentTxn);\n\t\t\t\t\t\ttxnCallbacks[j] = result;\n\t\t\t\t\t} catch(error) {\n\t\t\t\t\t\tclearWriteTxn(parentTxn);\n\t\t\t\t\t\tenv.abortTxn();\n\t\t\t\t\t\ttxnError(error, txnCallbacks, j);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet result = userTxnCallback();\n\t\t\t\t\t\ttxnCallbacks[j] = result;\n\t\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\t\thasUnresolvedTxns = true;\n\t\t\t\t\t\t\tawait result;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(error) {\n\t\t\t\t\t\ttxnError(error, txnCallbacks, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnextTxnCallbacks = [];\n\t\tclearWriteTxn(null);\n\t\tif (hasUnresolvedTxns) {\n\t\t\tenv.resumeWriting();\n\t\t}\n\t\tfunction txnError(error, txnCallbacks, i) {\n\t\t\t(txnCallbacks.errors || (txnCallbacks.errors = []))[i] = error;\n\t\t\ttxnCallbacks[i] = CALLBACK_THREW;\n\t\t}\n\t}\n\tfunction finishBatch() {\n\t\tdynamicBytes.uint32[(dynamicBytes.position + 1) << 1] = 0; // clear out the next slot\n\t\tlet writeStatus = atomicStatus(dynamicBytes.uint32, (dynamicBytes.position++) << 1, 2); // atomically write the end block\n\t\tnextResolution.flagPosition += 2;\n\t\tif (writeStatus & WAITING_OPERATION) {\n\t\t\twrite(env.address, 0);\n\t\t}\n\t}\n\tfunction clearWriteTxn(parentTxn) {\n\t\t// TODO: We might actually want to track cursors in a write txn and manually\n\t\t// close them.\n\t\tif (writeTxn && writeTxn.refCount > 0)\n\t\t\twriteTxn.isDone = true;\n\t\tenv.writeTxn = writeTxn = parentTxn || null;\n\t}\n\tObject.assign(LMDBStore.prototype, {\n\t\tput(key, value, versionOrOptions, ifVersion) {\n\t\t\tlet callback, flags = 15, type = typeof versionOrOptions;\n\t\t\tif (type == 'object') {\n\t\t\t\tif (versionOrOptions.noOverwrite)\n\t\t\t\t\tflags |= 0x10;\n\t\t\t\tif (versionOrOptions.noDupData)\n\t\t\t\t\tflags |= 0x20;\n\t\t\t\tif (versionOrOptions.append)\n\t\t\t\t\tflags |= 0x20000;\n\t\t\t\tif (versionOrOptions.ifVersion != undefined)\n\t\t\t\t\tifVersion = versionsOrOptions.ifVersion;\n\t\t\t\tversionOrOptions = versionOrOptions.version;\n\t\t\t\tif (typeof ifVersion == 'function')\n\t\t\t\t\tcallback = ifVersion;\n\t\t\t} else if (type == 'function') {\n\t\t\t\tcallback = versionOrOptions;\n\t\t\t}\n\t\t\treturn writeInstructions(flags, this, key, value, this.useVersions ? versionOrOptions || 0 : undefined, ifVersion)(callback);\n\t\t},\n\t\tremove(key, ifVersionOrValue, callback) {\n\t\t\tlet flags = 13;\n\t\t\tlet ifVersion, value;\n\t\t\tif (ifVersionOrValue !== undefined) {\n\t\t\t\tif (typeof ifVersionOrValue == 'function')\n\t\t\t\t\tcallback = ifVersionOrValue;\n\t\t\t\telse if (ifVersionOrValue === IF_EXISTS && !callback)\n\t\t\t\t\t// we have a handler for IF_EXISTS in the callback handler for remove\n\t\t\t\t\tcallback = ifVersionOrValue;\n\t\t\t\telse if (this.useVersions)\n\t\t\t\t\tifVersion = ifVersionOrValue;\n\t\t\t\telse {\n\t\t\t\t\tflags = 14;\n\t\t\t\t\tvalue = ifVersionOrValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn writeInstructions(flags, this, key, value, undefined, ifVersion)(callback);\n\t\t},\n\t\tdel(key, options, callback) {\n\t\t\treturn this.remove(key, options, callback);\n\t\t},\n\t\tifNoExists(key, callback) {\n\t\t\treturn this.ifVersion(key, null, callback);\n\t\t},\n\t\tifVersion(key, version, callback, options) {\n\t\t\tif (!callback) {\n\t\t\t\treturn new Batch((operations, callback) => {\n\t\t\t\t\tlet promise = this.ifVersion(key, version, operations, options);\n\t\t\t\t\tif (callback)\n\t\t\t\t\t\tpromise.then(callback);\n\t\t\t\t\treturn promise;\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (writeTxn) {\n\t\t\t\tif (version === undefined || this.doesExist(key, version)) {\n\t\t\t\t\tcallback();\n\t\t\t\t\treturn SYNC_PROMISE_SUCCESS;\n\t\t\t\t}\n\t\t\t\treturn SYNC_PROMISE_FAIL;\n\t\t\t}\n\t\t\tlet flags = key === undefined || version === undefined ? 1 : 4;\n\t\t\tif (options?.ifLessThan)\n\t\t\t\tflags |= CONDITIONAL_VERSION_LESS_THAN;\n\t\t\tif (options?.allowNotFound)\n\t\t\t\tflags |= CONDITIONAL_ALLOW_NOTFOUND;\n\t\t\tlet finishStartWrite = writeInstructions(flags, this, key, undefined, undefined, version);\n\t\t\tlet promise;\n\t\t\tbatchDepth += 2;\n\t\t\tif (batchDepth > 2)\n\t\t\t\tpromise = finishStartWrite();\n\t\t\telse {\n\t\t\t\twriteBatchStart = () => {\n\t\t\t\t\tpromise = finishStartWrite();\n\t\t\t\t};\n\t\t\t\toutstandingBatchCount = 0;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\tcallback();\n\t\t\t\t} else {\n\t\t\t\t\tfor (let i = 0, l = callback.length; i < l; i++) {\n\t\t\t\t\t\tlet operation = callback[i];\n\t\t\t\t\t\tthis[operation.type](operation.key, operation.value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (!promise) {\n\t\t\t\t\tfinishBatch();\n\t\t\t\t\tbatchDepth -= 2;\n\t\t\t\t\tpromise = finishStartWrite(); // finish write once all the operations have been written (and it hasn't been written prematurely)\n\t\t\t\t\twriteBatchStart = null;\n\t\t\t\t} else {\n\t\t\t\t\tbatchDepth -= 2;\n\t\t\t\t\tfinishBatch();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn promise;\n\t\t},\n\t\tbatch(callbackOrOperations) {\n\t\t\treturn this.ifVersion(undefined, undefined, callbackOrOperations);\n\t\t},\n\t\tdrop(callback) {\n\t\t\treturn writeInstructions(1024 + 12, this, Buffer.from([]), undefined, undefined, undefined)(callback);\n\t\t},\n\t\tclearAsync(callback) {\n\t\t\tif (this.encoder) {\n\t\t\t\tif (this.encoder.clearSharedData)\n\t\t\t\t\tthis.encoder.clearSharedData()\n\t\t\t\telse if (this.encoder.structures)\n\t\t\t\t\tthis.encoder.structures = []\n\t\t\t}\n\t\t\treturn writeInstructions(12, this, Buffer.from([]), undefined, undefined, undefined)(callback);\n\t\t},\n\t\t_triggerError() {\n\t\t\tfinishBatch();\n\t\t},\n\n\t\tputSync(key, value, versionOrOptions, ifVersion) {\n\t\t\tif (writeTxn)\n\t\t\t\treturn this.put(key, value, versionOrOptions, ifVersion);\n\t\t\telse\n\t\t\t\treturn this.transactionSync(() =>\n\t\t\t\t\tthis.put(key, value, versionOrOptions, ifVersion) == SYNC_PROMISE_SUCCESS, overlappingSync? 0x10002 : 2); // non-abortable, async flush\n\t\t},\n\t\tremoveSync(key, ifVersionOrValue) {\n\t\t\tif (writeTxn)\n\t\t\t\treturn this.remove(key, ifVersionOrValue);\n\t\t\telse\n\t\t\t\treturn this.transactionSync(() =>\n\t\t\t\t\tthis.remove(key, ifVersionOrValue) == SYNC_PROMISE_SUCCESS, overlappingSync? 0x10002 : 2); // non-abortable, async flush\n\t\t},\n\t\ttransaction(callback) {\n\t\t\tif (writeTxn && !nextTxnCallbacks.isExecuting) {\n\t\t\t\t// already nested in a transaction, just execute and return\n\t\t\t\treturn callback();\n\t\t\t}\n\t\t\treturn this.transactionAsync(callback);\n\t\t},\n\t\tchildTransaction(callback) {\n\t\t\tif (useWritemap)\n\t\t\t\tthrow new Error('Child transactions are not supported in writemap mode');\n\t\t\tif (writeTxn) {\n\t\t\t\tlet parentTxn = writeTxn;\n\t\t\t\tlet thisTxn = env.writeTxn = writeTxn = { write: true };\n\t\t\t\tenv.beginTxn(1); // abortable\n\t\t\t\tlet callbackDone, finishTxn;\n\t\t\t\ttry {\n\t\t\t\t\treturn writeTxn.childResults = when(callback(), finishTxn = (result) => {\n\t\t\t\t\t\tif (writeTxn !== thisTxn) // need to wait for child txn to finish asynchronously\n\t\t\t\t\t\t\treturn writeTxn.childResults.then(() => finishTxn(result));\n\t\t\t\t\t\tcallbackDone = true;\n\t\t\t\t\t\tif (result === ABORT)\n\t\t\t\t\t\t\tenv.abortTxn();\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tenv.commitTxn();\n\t\t\t\t\t\tclearWriteTxn(parentTxn);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}, (error) => {\n\t\t\t\t\t\tenv.abortTxn();\n\t\t\t\t\t\tclearWriteTxn(parentTxn);\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t});\n\t\t\t\t} catch(error) {\n\t\t\t\t\tif (!callbackDone)\n\t\t\t\t\t\tenv.abortTxn();\n\t\t\t\t\tclearWriteTxn(parentTxn);\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.transactionAsync(callback, true);\n\t\t},\n\t\ttransactionAsync(callback, asChild) {\n\t\t\tlet txnIndex;\n\t\t\tlet txnCallbacks;\n\t\t\tif (lastQueuedResolution.callbacks) {\n\t\t\t\ttxnCallbacks = lastQueuedResolution.callbacks;\n\t\t\t\ttxnIndex = txnCallbacks.push(asChild ? { callback, asChild } : callback) - 1;\n\t\t\t} else if (nextTxnCallbacks.isExecuting) {\n\t\t\t\ttxnCallbacks = [asChild ? { callback, asChild } : callback];\n\t\t\t\ttxnCallbacks.results = commitPromise;\n\t\t\t\tnextTxnCallbacks.push(txnCallbacks);\n\t\t\t\ttxnIndex = 0;\n\t\t\t} else {\n\t\t\t\tif (writeTxn)\n\t\t\t\t\tthrow new Error('Can not enqueue transaction during write txn');\n\t\t\t\tlet finishWrite = writeInstructions(8 | (this.strictAsyncOrder ? 0x100000 : 0), this);\n\t\t\t\ttxnCallbacks = [asChild ? { callback, asChild } : callback];\n\t\t\t\tlastQueuedResolution.callbacks = txnCallbacks;\n\t\t\t\tlastQueuedResolution.id = Math.random();\n\t\t\t\ttxnCallbacks.results = finishWrite();\n\t\t\t\ttxnIndex = 0;\n\t\t\t}\n\t\t\treturn txnCallbacks.results.then((results) => {\n\t\t\t\tlet result = txnCallbacks[txnIndex];\n\t\t\t\tif (result === CALLBACK_THREW)\n\t\t\t\t\tthrow txnCallbacks.errors[txnIndex];\n\t\t\t\treturn result;\n\t\t\t});\n\t\t},\n\t\ttransactionSync(callback, flags) {\n\t\t\tif (writeTxn) {\n\t\t\t\tif (!useWritemap && (flags == undefined || (flags & 1))) // can't use child transactions in write maps\n\t\t\t\t\t// already nested in a transaction, execute as child transaction (if possible) and return\n\t\t\t\t\treturn this.childTransaction(callback);\n\t\t\t\tlet result = callback(); // else just run in current transaction\n\t\t\t\tif (result == ABORT && !abortedNonChildTransactionWarn) {\n\t\t\t\t\tconsole.warn('Can not abort a transaction inside another transaction with ' + (this.cache ? 'caching enabled' : 'useWritemap enabled'));\n\t\t\t\t\tabortedNonChildTransactionWarn = true;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tlet callbackDone, finishTxn;\n\t\t\tthis.transactions++;\n\t\t\tenv.beginTxn(flags == undefined ? 3 : flags);\n\t\t\tlet thisTxn = writeTxn = env.writeTxn = { write: true };\n\t\t\ttry {\n\t\t\t\tthis.emit('begin-transaction');\n\t\t\t\treturn writeTxn.childResults = when(callback(), finishTxn = (result) => {\n\t\t\t\t\tif (writeTxn !== thisTxn) // need to wait for child txn to finish asynchronously\n\t\t\t\t\t\treturn writeTxn.childResults.then(() => finishTxn(result));\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcallbackDone = true;\n\t\t\t\t\t\tif (result === ABORT)\n\t\t\t\t\t\t\tenv.abortTxn();\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlet hasWrites = env.commitTxn();\n\t\t\t\t\t\t\tresetReadTxn();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tclearWriteTxn(null);\n\t\t\t\t\t}\n\t\t\t\t}, (error) => {\n\t\t\t\t\ttry { env.abortTxn(); } catch(e) {}\n\t\t\t\t\tclearWriteTxn(null);\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t\t} catch(error) {\n\t\t\t\tif (!callbackDone)\n\t\t\t\t\ttry { env.abortTxn(); } catch(e) {}\n\t\t\t\tclearWriteTxn(null);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t},\n\t\ttransactionSyncStart(callback) {\n\t\t\treturn this.transactionSync(callback, 0);\n\t\t},\n\t\t// make the db a thenable/promise-like for when the last commit is committed\n\t\tcommitted: committed = {\n\t\t\tthen(onfulfilled, onrejected) {\n\t\t\t\tif (commitPromise)\n\t\t\t\t\treturn commitPromise.then(onfulfilled, onrejected);\n\t\t\t\tif (lastWritePromise) // always resolve to true\n\t\t\t\t\treturn lastWritePromise.then(() => onfulfilled(true), onrejected);\n\t\t\t\treturn SYNC_PROMISE_SUCCESS.then(onfulfilled, onrejected);\n\t\t\t}\n\t\t},\n\t\tflushed: {\n\t\t\t// make this a thenable for when the commit is flushed to disk\n\t\t\tthen(onfulfilled, onrejected) {\n\t\t\t\tif (flushPromise)\n\t\t\t\t\tflushPromise.hasCallbacks = true\n\t\t\t\treturn Promise.all([flushPromise || committed, lastSyncTxnFlush]).then(onfulfilled, onrejected);\n\t\t\t}\n\t\t},\n\t\t_endWrites(resolvedPromise, resolvedSyncPromise) {\n\t\t\tthis.put = this.remove = this.del = this.batch = this.removeSync = this.putSync = this.transactionAsync = this.drop = this.clearAsync = () => { throw new Error('Database is closed') };\n\t\t\t// wait for all txns to finish, checking again after the current txn is done\n\t\t\tlet finalPromise = flushPromise || commitPromise || lastWritePromise;\n\t\t\tif (flushPromise)\n\t\t\t\tflushPromise.hasCallbacks = true\n\t\t\tlet finalSyncPromise = lastSyncTxnFlush;\n\t\t\tif (finalPromise && resolvedPromise != finalPromise ||\n\t\t\t\t\tfinalSyncPromise && resolvedSyncPromise != finalSyncPromise) {\n\t\t\t\treturn Promise.all([finalPromise, finalSyncPromise]).then(() => this._endWrites(finalPromise, finalSyncPromise), () => this._endWrites(finalPromise, finalSyncPromise));\n\t\t\t}\n\t\t\tObject.defineProperty(env, 'sync', { value: null });\n\t\t},\n\t\ton(event, callback) {\n\t\t\tif (event == 'beforecommit') {\n\t\t\t\teventTurnBatching = true;\n\t\t\t\tbeforeCommitCallbacks.push(callback);\n\t\t\t} else if (event == 'aftercommit')\n\t\t\t\tafterCommitCallbacks.push(callback);\n\t\t\telse\n\t\t\t\tsuper.on(event, callback);\n\t\t}\n\t});\n}\n\nclass Batch extends Array {\n\tconstructor(callback) {\n\t\tsuper();\n\t\tthis.callback = callback;\n\t}\n\tput(key, value) {\n\t\tthis.push({ type: 'put', key, value });\n\t}\n\tdel(key) {\n\t\tthis.push({ type: 'del', key });\n\t}\n\tclear() {\n\t\tthis.splice(0, this.length);\n\t}\n\twrite(callback) {\n\t\treturn this.callback(this, callback);\n\t}\n}\nexport function asBinary(buffer) {\n\treturn {\n\t\t['\\x10binary-data\\x02']: buffer\n\t};\n}\n","const SKIP = {};\nconst DONE = {\n\tvalue: null,\n\tdone: true,\n}\nif (!Symbol.asyncIterator) {\n\tSymbol.asyncIterator = Symbol.for('Symbol.asyncIterator');\n}\n\nexport class RangeIterable {\n\tconstructor(sourceArray) {\n\t\tif (sourceArray) {\n\t\t\tthis.iterate = sourceArray[Symbol.iterator].bind(sourceArray);\n\t\t}\n\t}\n\tmap(func) {\n\t\tlet source = this;\n\t\tlet iterable = new RangeIterable();\n\t\titerable.iterate = (async) => {\n\t\t\tlet iterator = source[Symbol.iterator](async);\n\t\t\tlet i = 0;\n\t\t\treturn {\n\t\t\t\tnext(resolvedResult) {\n\t\t\t\t\tlet result;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tlet iteratorResult;\n\t\t\t\t\t\tif (resolvedResult) {\n\t\t\t\t\t\t\titeratorResult = resolvedResult;\n\t\t\t\t\t\t\tresolvedResult = null; // don't go in this branch on next iteration\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\titeratorResult = iterator.next();\n\t\t\t\t\t\t\tif (iteratorResult.then) {\n\t\t\t\t\t\t\t\treturn iteratorResult.then(iteratorResult => this.next(iteratorResult));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (iteratorResult.done === true) {\n\t\t\t\t\t\t\tthis.done = true;\n\t\t\t\t\t\t\tif (iterable.onDone) iterable.onDone();\n\t\t\t\t\t\t\treturn iteratorResult;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult = func(iteratorResult.value, i++);\n\t\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\t\treturn result.then(result =>\n\t\t\t\t\t\t\t\tresult === SKIP ?\n\t\t\t\t\t\t\t\t\tthis.next() :\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvalue: result\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} while(result === SKIP);\n\t\t\t\t\tif (result === DONE) {\n\t\t\t\t\t\tif (iterable.onDone) iterable.onDone();\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue: result\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\treturn() {\n\t\t\t\t\tif (iterable.onDone) iterable.onDone();\n\t\t\t\t\treturn iterator.return();\n\t\t\t\t},\n\t\t\t\tthrow() {\n\t\t\t\t\tif (iterable.onDone) iterable.onDone();\n\t\t\t\t\treturn iterator.throw();\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\treturn iterable;\n\t}\n\t[Symbol.asyncIterator]() {\n\t\treturn this.iterator = this.iterate();\n\t}\n\t[Symbol.iterator]() {\n\t\treturn this.iterator = this.iterate();\n\t}\n\tfilter(func) {\n\t\treturn this.map(element => func(element) ? element : SKIP);\n\t}\n\n\tforEach(callback) {\n\t\tlet iterator = this.iterator = this.iterate();\n\t\tlet result;\n\t\twhile ((result = iterator.next()).done !== true) {\n\t\t\tcallback(result.value);\n\t\t}\n\t}\n\tconcat(secondIterable) {\n\t\tlet concatIterable = new RangeIterable();\n\t\tconcatIterable.iterate = (async) => {\n\t\t\tlet iterator = this.iterator = this.iterate();\n\t\t\tlet isFirst = true;\n\t\t\treturn {\n\t\t\t\tnext() {\n\t\t\t\t\tlet result = iterator.next();\n\t\t\t\t\tif (result.done) {\n\t\t\t\t\t\tif (isFirst) {\n\t\t\t\t\t\t\tisFirst = false;\n\t\t\t\t\t\t\titerator = secondIterable[Symbol.iterator](async);\n\t\t\t\t\t\t\tresult = iterator.next();\n\t\t\t\t\t\t\tif (result.done && concatIterable.onDone) iterable.onDone();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (concatIterable.onDone) concatIterable.onDone();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t},\n\t\t\t\treturn() {\n\t\t\t\t\tif (concatIterable.onDone) concatIterable.onDone();\n\t\t\t\t\treturn iterator.return();\n\t\t\t\t},\n\t\t\t\tthrow() {\n\t\t\t\t\tif (concatIterable.onDone) concatIterable.onDone();\n\t\t\t\t\treturn iterator.throw();\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\treturn concatIterable;\n\t}\n\n\tflatMap(callback) {\n\t\tlet mappedIterable = new RangeIterable();\n\t\tmappedIterable.iterate = (async) => {\n\t\t\tlet iterator = this.iterator = this.iterate(async);\n\t\t\tlet isFirst = true;\n\t\t\tlet currentSubIterator;\n\t\t\treturn {\n\t\t\t\tnext() {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (currentSubIterator) {\n\t\t\t\t\t\t\tlet result = currentSubIterator.next();\n\t\t\t\t\t\t\tif (!result.done) {\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet result = iterator.next();\n\t\t\t\t\t\tif (result.done) {\n\t\t\t\t\t\t\tif (mappedIterable.onDone) mappedIterable.onDone();\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet value = callback(result.value);\n\t\t\t\t\t\tif (Array.isArray(value) || value instanceof RangeIterable)\n\t\t\t\t\t\t\tcurrentSubIterator = value[Symbol.iterator]();\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcurrentSubIterator = null;\n\t\t\t\t\t\t\treturn { value };\n\t\t\t\t\t\t}\n\t\t\t\t\t} while(true);\n\t\t\t\t},\n\t\t\t\treturn() {\n\t\t\t\t\tif (mappedIterable.onDone) mappedIterable.onDone();\n\t\t\t\t\tif (currentSubIterator)\n\t\t\t\t\t\tcurrentSubIterator.return();\n\t\t\t\t\treturn iterator.return();\n\t\t\t\t},\n\t\t\t\tthrow() {\n\t\t\t\t\tif (mappedIterable.onDone) mappedIterable.onDone();\n\t\t\t\t\tif (currentSubIterator)\n\t\t\t\t\t\tcurrentSubIterator.throw();\n\t\t\t\t\treturn iterator.throw();\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\treturn mappedIterable;\n\t}\n\n\tslice(start, end) {\n\t\treturn this.map((element, i) => {\n\t\t\tif (i < start)\n\t\t\t\treturn SKIP;\n\t\t\tif (i >= end) {\n\t\t\t\tDONE.value = element;\n\t\t\t\treturn DONE;\n\t\t\t}\n\t\t\treturn element;\n\t\t});\n\t}\n\tnext() {\n\t\tif (!this.iterator)\n\t\t\tthis.iterator = this.iterate();\n\t\treturn this.iterator.next();\n\t}\n\ttoJSON() {\n\t\tif (this.asArray && this.asArray.forEach) {\n\t\t\treturn this.asArray;\n\t\t}\n\t\tthrow new Error('Can not serialize async iterables without first calling resolveJSON');\n\t\t//return Array.from(this)\n\t}\n\tget asArray() {\n\t\tif (this._asArray)\n\t\t\treturn this._asArray;\n\t\tlet promise = new Promise((resolve, reject) => {\n\t\t\tlet iterator = this.iterate();\n\t\t\tlet array = [];\n\t\t\tlet iterable = this;\n\t\t\tObject.defineProperty(array, 'iterable', { value: iterable });\n\t\t\tfunction next(result) {\n\t\t\t\twhile (result.done !== true) {\n\t\t\t\t\tif (result.then) {\n\t\t\t\t\t\treturn result.then(next);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tarray.push(result.value);\n\t\t\t\t\t}\n\t\t\t\t\tresult = iterator.next();\n\t\t\t\t}\n\t\t\t\tresolve(iterable._asArray = array);\n\t\t\t}\n\t\t\tnext(iterator.next());\n\t\t});\n\t\tpromise.iterable = this;\n\t\treturn this._asArray || (this._asArray = promise);\n\t}\n\tresolveData() {\n\t\treturn this.asArray;\n\t}\n}\nRangeIterable.prototype.DONE = DONE;","import { getAddress, orderedBinary } from './native.js';\n\nconst REUSE_BUFFER_MODE = 512;\nconst writeUint32Key = (key, target, start) => {\n\t(target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length))).setUint32(start, key, true);\n\treturn start + 4;\n};\nconst readUint32Key = (target, start) => {\n\treturn (target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length))).getUint32(start, true);\n};\nconst writeBufferKey = (key, target, start) => {\n\ttarget.set(key, start);\n\treturn key.length + start;\n};\nconst Uint8ArraySlice = Uint8Array.prototype.slice;\nconst readBufferKey = (target, start, end) => {\n\treturn Uint8ArraySlice.call(target, start, end);\n};\n\nlet lastEncodedValue, bytes;\nexport function applyKeyHandling(store) {\n \tif (store.encoding == 'ordered-binary') {\n\t\tstore.encoder = store.decoder = {\n\t\t\twriteKey: orderedBinary.writeKey,\n\t\t\treadKey: orderedBinary.readKey,\n\t\t};\n\t}\n\tif (store.encoder && store.encoder.writeKey && !store.encoder.encode) {\n\t\tstore.encoder.encode = function(value, mode) {\n\t\t\tif (typeof value !== 'object' && value && value === lastEncodedValue) {\n\t\t\t\t// reuse the last serialized bytes\n\t\t\t\t// NOTE that it is very important that nothing else calls saveKey with saveTo: false\n\t\t\t} else {\n\t\t\t\tlastEncodedValue = value;\n\t\t\t\tbytes = saveKey(value, this.writeKey, false, store.maxKeySize);\n\t\t\t}\n\t\t\tif (bytes.end > 0 && !(REUSE_BUFFER_MODE & mode)) {\n\t\t\t\treturn bytes.subarray(bytes.start, bytes.end);\n\t\t\t}\n\t\t\treturn bytes;\n\t\t};\n\t\tstore.encoder.copyBuffers = true; // just an indicator for the buffer reuse in write.js\n\t}\n\tif (store.decoder && store.decoder.readKey && !store.decoder.decode) {\n\t\tstore.decoder.decode = function(buffer) { return this.readKey(buffer, 0, buffer.length); };\n\t\tstore.decoderCopies = true;\n\t}\n\tif (store.keyIsUint32 || store.keyEncoding == 'uint32') {\n\t\tstore.writeKey = writeUint32Key;\n\t\tstore.readKey = readUint32Key;\n\t} else if (store.keyIsBuffer || store.keyEncoding == 'binary') {\n\t\tstore.writeKey = writeBufferKey;\n\t\tstore.readKey = readBufferKey;\n\t} else if (store.keyEncoder) {\n\t\tstore.writeKey = store.keyEncoder.writeKey;\n\t\tstore.readKey = store.keyEncoder.readKey;\n\t} else {\n\t\tstore.writeKey = orderedBinary.writeKey;\n\t\tstore.readKey = orderedBinary.readKey;\n\t}\n}\n\nlet saveBuffer, uint32, saveDataView = { setFloat64() {}, setUint32() {} }, saveDataAddress;\nlet savePosition = 8000;\nlet DYNAMIC_KEY_BUFFER_SIZE = 8192;\nfunction allocateSaveBuffer() {\n\tsaveBuffer = typeof Buffer != 'undefined' ? Buffer.alloc(DYNAMIC_KEY_BUFFER_SIZE) : new Uint8Array(DYNAMIC_KEY_BUFFER_SIZE);\n\tuint32 = null;\n\tsaveBuffer.buffer.address = getAddress(saveBuffer.buffer);\n\tsaveDataAddress = saveBuffer.buffer.address;\n\t// TODO: Conditionally only do this for key sequences?\n\tsaveDataView.setUint32(savePosition, 0xffffffff);\n\tsaveDataView.setFloat64(savePosition + 4, saveDataAddress, true); // save a pointer from the old buffer to the new address for the sake of the prefetch sequences\n\tsaveDataView = saveBuffer.dataView || (saveBuffer.dataView = new DataView(saveBuffer.buffer, saveBuffer.byteOffset, saveBuffer.byteLength));\n\tsavePosition = 0;\n}\nexport function saveKey(key, writeKey, saveTo, maxKeySize, flags) {\n\tif (savePosition > 7800) {\n\t\tallocateSaveBuffer();\n\t}\n\tlet start = savePosition;\n\ttry {\n\t\tsavePosition = key === undefined ? start + 4 :\n\t\t\twriteKey(key, saveBuffer, start + 4);\n\t} catch (error) {\n\t\tsaveBuffer.fill(0, start + 4); // restore zeros\n\t\tif (error.name == 'RangeError') {\n\t\t\tif (8180 - start < maxKeySize) {\n\t\t\t\tallocateSaveBuffer(); // try again:\n\t\t\t\treturn saveKey(key, writeKey, saveTo, maxKeySize);\n\t\t\t}\n\t\t\tthrow new Error('Key was too large, max key size is ' + maxKeySize);\n\t\t} else\n\t\t\tthrow error;\n\t}\n\tlet length = savePosition - start - 4;\n\tif (length > maxKeySize) {\n\t\tthrow new Error('Key of size ' + length + ' was too large, max key size is ' + maxKeySize);\n\t}\n\tif (savePosition >= 8160) { // need to reserve enough room at the end for pointers\n\t\tsavePosition = start // reset position\n\t\tallocateSaveBuffer(); // try again:\n\t\treturn saveKey(key, writeKey, saveTo, maxKeySize);\n\t}\n\tif (saveTo) {\n\t\tsaveDataView.setUint32(start, flags ? length | flags : length, true); // save the length\n\t\tsaveTo.saveBuffer = saveBuffer;\n\t\tsavePosition = (savePosition + 12) & 0xfffffc;\n\t\treturn start + saveDataAddress;\n\t} else {\n\t\tsaveBuffer.start = start + 4;\n\t\tsaveBuffer.end = savePosition;\n\t\tsavePosition = (savePosition + 7) & 0xfffff8; // full 64-bit word alignment since these are usually copied\n\t\treturn saveBuffer;\n\t}\n}","export function levelup(store) {\n\treturn Object.assign(Object.create(store), {\n\t\tget(key, options, callback) {\n\t\t\tlet result = store.get(key);\n\t\t\tif (typeof options == 'function')\n\t\t\t\tcallback = options;\n\t\t\tif (callback) {\n\t\t\t\tif (result === undefined)\n\t\t\t\t\tcallback(new NotFoundError());\n\t\t\t\telse\n\t\t\t\t\tcallback(null, result);\n\t\t\t} else {\n\t\t\t\tif (result === undefined)\n\t\t\t\t\treturn Promise.reject(new NotFoundError());\n\t\t\t\telse\n\t\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\t\t},\n\t});\n}\nclass NotFoundError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'NotFoundError';\n\t\tthis.notFound = true;\n\t}\n}","import { EventEmitter } from 'events';\nimport { setExternals, setNativeFunctions, Dbi } from './native.js';\nimport { arch, tmpdir, platform } from 'os';\nimport fs from 'fs';\nimport { Encoder as MsgpackrEncoder } from 'msgpackr';\nimport { WeakLRUCache } from 'weak-lru-cache';\nimport * as orderedBinary from 'ordered-binary';\n\n\norderedBinary.enableNullTermination();\nsetExternals({\n\tarch, fs, tmpdir, MsgpackrEncoder, WeakLRUCache, orderedBinary,\n\tEventEmitter, os: platform(), onExit(callback) {\n\t\tif (process.getMaxListeners() < process.listenerCount('exit') + 8)\n\t\t\tprocess.setMaxListeners(process.listenerCount('exit') + 8);\n\t\tprocess.on('exit', callback);\n\t},\n});\nexport { toBufferKey as keyValueToBuffer, compareKeys, compareKeys as compareKey, fromBufferKey as bufferToKeyValue } from 'ordered-binary';\nexport { ABORT, IF_EXISTS, asBinary } from './write.js';\nimport { ABORT, IF_EXISTS, asBinary } from './write.js';\nexport { levelup } from './level.js';\nimport { levelup } from './level.js';\nexport { clearKeptObjects } from './native.js';\nimport { nativeAddon } from './native.js';\nexport let { noop } = nativeAddon;\nexport { open, openAsClass, getLastVersion, allDbs } from './open.js';\nimport { toBufferKey as keyValueToBuffer, compareKeys as compareKey, fromBufferKey as bufferToKeyValue } from 'ordered-binary';\nimport { open, openAsClass, getLastVersion } from './open.js';\nexport const TransactionFlags = {\n\tABORTABLE: 1,\n\tSYNCHRONOUS_COMMIT: 2,\n\tNO_SYNC_FLUSH: 0x10000,\n};\nexport default {\n\topen, openAsClass, getLastVersion, compareKey, keyValueToBuffer, bufferToKeyValue, ABORT, IF_EXISTS, asBinary, levelup, TransactionFlags\n};\n","import { RangeIterable }  from './util/RangeIterable.js';\nimport { getAddress, Cursor, Txn, orderedBinary, lmdbError, getByBinary, detachBuffer, setGlobalBuffer, prefetch, iterate, position as doPosition, resetTxn, getCurrentValue, getCurrentShared, getStringByBinary, globalBuffer, getSharedBuffer, startRead, setReadCallback } from './native.js';\nimport { saveKey }  from './keys.js';\nimport lmdb from \"./index.js\";\nconst IF_EXISTS = 3.542694326329068e-103;\nconst ITERATOR_DONE = { done: true, value: undefined };\nconst Uint8ArraySlice = Uint8Array.prototype.slice;\nlet getValueBytes = globalBuffer;\nif (!getValueBytes.maxLength) {\n\tgetValueBytes.maxLength = getValueBytes.length;\n\tgetValueBytes.isGlobal = true;\n\tObject.defineProperty(getValueBytes, 'length', { value: getValueBytes.length, writable: true, configurable: true });\n}\nconst START_ADDRESS_POSITION = 4064;\nconst NEW_BUFFER_THRESHOLD = 0x8000;\nconst SOURCE_SYMBOL = Symbol.for('source');\nexport const UNMODIFIED = {};\nlet mmaps = [];\n\nexport function addReadMethods(LMDBStore, {\n\tmaxKeySize, env, keyBytes, keyBytesView, getLastVersion, getLastTxnId\n}) {\n\tlet readTxn, readTxnRenewed, asSafeBuffer = false;\n\tlet renewId = 1;\n\tlet outstandingReads = 0;\n\tObject.assign(LMDBStore.prototype, {\n\t\tgetString(id, options) {\n\t\t\tlet txn = env.writeTxn || (options && options.transaction) || (readTxnRenewed ? readTxn : renewReadTxn(this));\n\t\t\tlet string = getStringByBinary(this.dbAddress, this.writeKey(id, keyBytes, 0), txn.address || 0);\n\t\t\tif (typeof string === 'number') { // indicates the buffer wasn't large enough\n\t\t\t\tthis._allocateGetBuffer(string);\n\t\t\t\t// and then try again\n\t\t\t\tstring = getStringByBinary(this.dbAddress, this.writeKey(id, keyBytes, 0), txn.address || 0);\n\t\t\t}\n\t\t\tif (string)\n\t\t\t\tthis.lastSize = string.length;\n\t\t\treturn string;\n\t\t},\n\t\tgetBinaryFast(id, options) {\n\t\t\tlet rc;\n\t\t\tlet txn = env.writeTxn || (options && options.transaction) || (readTxnRenewed ? readTxn : renewReadTxn(this));\n\t\t\trc = this.lastSize = getByBinary(this.dbAddress, this.writeKey(id, keyBytes, 0), (options && options.ifNotTxnId) || 0, txn.address || 0);\n\t\t\tif (rc < 0) {\n\t\t\t\tif (rc == -30798) // MDB_NOTFOUND\n\t\t\t\t\treturn; // undefined\n\t\t\t\tif (rc == -30004) // txn id matched\n\t\t\t\t\treturn UNMODIFIED;\n\t\t\t\tif (rc == -30781 /*MDB_BAD_VALSIZE*/ && this.writeKey(id, keyBytes, 0) == 0)\n\t\t\t\t\tthrow new Error(id === undefined ?\n\t\t\t\t\t'A key is required for get, but is undefined' :\n\t\t\t\t\t'Zero length key is not allowed in LMDB');\n\t\t\t\tif (rc == -30000) // int32 overflow, read uint32\n\t\t\t\t\trc = this.lastSize = keyBytesView.getUint32(0, true);\n\t\t\t\telse if (rc == -30001) {// shared buffer\n\t\t\t\t\tthis.lastSize = keyBytesView.getUint32(0, true);\n\t\t\t\t\tlet bufferId = keyBytesView.getUint32(4, true);\n\t\t\t\t\treturn getMMapBuffer(bufferId, this.lastSize);\n\t\t\t\t} else\n\t\t\t\t\tthrow lmdbError(rc);\n\t\t\t}\n\t\t\tlet compression = this.compression;\n\t\t\tlet bytes = compression ? compression.getValueBytes : getValueBytes;\n\t\t\tif (rc > bytes.maxLength) {\n\t\t\t\t// this means the target buffer wasn't big enough, so the get failed to copy all the data from the database, need to either grow or use special buffer\n\t\t\t\treturn this._returnLargeBuffer(\n\t\t\t\t\t() => getByBinary(this.dbAddress, this.writeKey(id, keyBytes, 0), 0, txn.address || 0));\n\t\t\t}\n\t\t\tbytes.length = this.lastSize;\n\t\t\treturn bytes;\n\t\t},\n\t\tgetBFAsync(id, options, callback) {\n\t\t\tlet txn = env.writeTxn || (options && options.transaction) || (readTxnRenewed ? readTxn : renewReadTxn(this));\n\t\t\ttxn.refCount = (txn.refCount || 0) + 1;\n\t\t\toutstandingReads++;\n\t\t\tlet address = recordReadInstruction(txn.address, this.db.dbi, id, this.writeKey, maxKeySize, ( rc, bufferId, offset, size ) => {\n\t\t\t\tif (rc && rc !== 1)\n\t\t\t\t\tcallback(lmdbError(rc));\n\t\t\t\toutstandingReads--;\n\t\t\t\tlet buffer = mmaps[bufferId];\n\t\t\t\tif (!buffer) {\n\t\t\t\t\tbuffer = mmaps[bufferId] = getSharedBuffer(bufferId, env.address);\n\t\t\t\t}\n\t\t\t\t//console.log({bufferId, offset, size})\n\t\t\t\tif (buffer.isSharedMap) {\n\t\t\t\t\t// using LMDB shared memory\n\t\t\t\t\t// TODO: We may want explicit support for clearing aborting the transaction on the next event turn,\n\t\t\t\t\t// but for now we are relying on the GC to cleanup transaction for larger blocks of memory\n\t\t\t\t\tlet bytes = new Uint8Array(buffer, offset, size);\n\t\t\t\t\tbytes.txn = txn;\n\t\t\t\t\tcallback(bytes, 0, size);\n\t\t\t\t} else {\n\t\t\t\t\t// using copied memory\n\t\t\t\t\ttxn.done(); // decrement and possibly abort\n\t\t\t\t\tcallback(buffer, offset, size);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (address) {\n\t\t\t\tstartRead(address, () => {\n\t\t\t\t\tresolveReads();\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\tgetAsync(id, options, callback) {\n\t\t\tlet promise;\n\t\t\tif (!callback)\n\t\t\t\tpromise = new Promise(resolve => callback = resolve);\n\t\t\tthis.getBFAsync(id, options, (buffer, offset, size) => {\n\t\t\t\tif (this.useVersions) {\n\t\t\t\t\t// TODO: And get the version\n\t\t\t\t\toffset += 8;\n\t\t\t\t\tsize -= 8;\n\t\t\t\t}\n\t\t\t\tlet bytes = new Uint8Array(buffer, offset, size);\n\t\t\t\tlet value;\n\t\t\t\tif (this.decoder) {\n\t\t\t\t\t// the decoder potentially uses the data from the buffer in the future and needs a stable buffer\n\t\t\t\t\tvalue = bytes && this.decoder.decode(bytes);\n\t\t\t\t} else if (this.encoding == 'binary') {\n\t\t\t\t\tvalue = bytes;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = Buffer.prototype.utf8Slice.call(bytes, 0, size);\n\t\t\t\t\tif (this.encoding == 'json' && value)\n\t\t\t\t\t\tvalue = JSON.parse(value);\n\t\t\t\t}\n\t\t\t\tcallback(value);\n\t\t\t});\n\t\t\treturn promise;\n\t\t},\n\t\tretain(data, options) {\n\t\t\tif (!data)\n\t\t\t\treturn\n\t\t\tlet source = data[SOURCE_SYMBOL];\n\t\t\tlet buffer = source ? source.bytes : data;\n\t\t\tif (!buffer.isGlobal && !env.writeTxn) {\n\t\t\t\tlet txn = options?.transaction || (readTxnRenewed ? readTxn : renewReadTxn(this));\n\t\t\t\tbuffer.txn = txn;\n\t\t\t\ttxn.refCount = (txn.refCount || 0) + 1;\n\t\t\t\treturn data;\n\t\t\t} else {\n\t\t\t\tbuffer = Uint8ArraySlice.call(buffer, 0, this.lastSize);\n\t\t\t\tif (source) {\n\t\t\t\t\tsource.bytes = buffer;\n\t\t\t\t\treturn data;\n\t\t\t\t} else\n\t\t\t\t\treturn buffer;\n\t\t\t}\n\t\t},\n\t\t_returnLargeBuffer(getFast) {\n\t\t\tlet bytes;\n\t\t\tlet compression = this.compression;\n\t\t\tif (asSafeBuffer && this.lastSize > NEW_BUFFER_THRESHOLD) {\n\t\t\t\t// used by getBinary to indicate it should create a dedicated buffer to receive this\n\t\t\t\tlet bytesToRestore\n\t\t\t\ttry {\n\t\t\t\t\tif (compression) {\n\t\t\t\t\t\tbytesToRestore = compression.getValueBytes;\n\t\t\t\t\t\tlet dictionary = compression.dictionary || [];\n\t\t\t\t\t\tlet dictLength = (dictionary.length >> 3) << 3;// make sure it is word-aligned\n\t\t\t\t\t\tbytes = makeReusableBuffer(this.lastSize);\n\t\t\t\t\t\tcompression.setBuffer(bytes.buffer, bytes.byteOffset, this.lastSize, dictionary, dictLength);\n\t\t\t\t\t\tcompression.getValueBytes = bytes;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbytesToRestore = getValueBytes;\n\t\t\t\t\t\tsetGlobalBuffer(bytes = getValueBytes = makeReusableBuffer(this.lastSize));\n\t\t\t\t\t}\n\t\t\t\t\tgetFast();\n\t\t\t\t} finally {\n\t\t\t\t\tif (compression) {\n\t\t\t\t\t\tlet dictLength = (compression.dictionary.length >> 3) << 3;\n\t\t\t\t\t\tcompression.setBuffer(bytesToRestore.buffer, bytesToRestore.byteOffset, bytesToRestore.maxLength, compression.dictionary, dictLength);\n\t\t\t\t\t\tcompression.getValueBytes = bytesToRestore;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsetGlobalBuffer(bytesToRestore);\n\t\t\t\t\t\tgetValueBytes = bytesToRestore;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn bytes;\n\t\t\t}\n\t\t\t// grow our shared/static buffer to accomodate the size of the data\n\t\t\tbytes = this._allocateGetBuffer(this.lastSize);\n\t\t\t// and try again\n\t\t\tgetFast();\n\t\t\tbytes.length = this.lastSize;\n\t\t\treturn bytes;\n\t\t},\n\t\t_allocateGetBuffer(lastSize) {\n\t\t\tlet newLength = Math.min(Math.max(lastSize * 2, 0x1000), 0xfffffff8);\n\t\t\tlet bytes;\n\t\t\tif (this.compression) {\n\t\t\t\tlet dictionary = this.compression.dictionary || Buffer.allocUnsafeSlow(0);\n\t\t\t\tlet dictLength = (dictionary.length >> 3) << 3;// make sure it is word-aligned\n\t\t\t\tbytes = Buffer.allocUnsafeSlow(newLength + dictLength);\n\t\t\t\tbytes.set(dictionary) // copy dictionary into start\n\t\t\t\t// the section after the dictionary is the target area for get values\n\t\t\t\tbytes = bytes.subarray(dictLength);\n\t\t\t\tthis.compression.setBuffer(bytes.buffer, bytes.byteOffset, newLength, dictionary, dictLength);\n\t\t\t\tbytes.maxLength = newLength;\n\t\t\t\tObject.defineProperty(bytes, 'length', { value: newLength, writable: true, configurable: true });\n\t\t\t\tthis.compression.getValueBytes = bytes;\n\t\t\t} else {\n\t\t\t\tbytes = makeReusableBuffer(newLength);\n\t\t\t\tsetGlobalBuffer(getValueBytes = bytes);\n\t\t\t}\n\t\t\tbytes.isGlobal = true;\n\t\t\treturn bytes;\n\t\t},\n\t\tgetBinary(id, options) {\n\t\t\ttry {\n\t\t\t\tasSafeBuffer = true;\n\t\t\t\tlet fastBuffer = this.getBinaryFast(id, options);\n\t\t\t\treturn fastBuffer && (fastBuffer.isGlobal ? Uint8ArraySlice.call(fastBuffer, 0, this.lastSize) : fastBuffer);\n\t\t\t} finally {\n\t\t\t\tasSafeBuffer = false;\n\t\t\t}\n\t\t},\n\t\tgetSharedBinary(id, options) {\n\t\t\tlet fastBuffer = this.getBinaryFast(id, options);\n\t\t\tif (fastBuffer) {\n\t\t\t\tif (fastBuffer.isGlobal || writeTxn)\n\t\t\t\t\treturn Uint8ArraySlice.call(fastBuffer, 0, this.lastSize)\n\t\t\t\tfastBuffer.txn = (options && options.transaction);\n\t\t\t\toptions.transaction.refCount = (options.transaction.refCount || 0) + 1;\n\t\t\t\treturn fastBuffer;\n\t\t\t}\n\t\t},\n\t\tget(id, options) {\n\t\t\tif (this.decoderCopies) {\n\t\t\t\t// the decoder copies any data, so we can use the fast binary retrieval that overwrites the same buffer space\n\t\t\t\tlet bytes = this.getBinaryFast(id, options);\n\t\t\t\treturn bytes && (bytes == UNMODIFIED ? UNMODIFIED : this.decoder.decode(bytes, options));\n\t\t\t}\n\t\t\tif (this.encoding == 'binary')\n\t\t\t\treturn this.getBinary(id, options);\n\t\t\tif (this.decoder) {\n\t\t\t\t// the decoder potentially uses the data from the buffer in the future and needs a stable buffer\n\t\t\t\tlet bytes = this.getBinary(id, options);\n\t\t\t\treturn bytes && (bytes == UNMODIFIED ? UNMODIFIED : this.decoder.decode(bytes));\n\t\t\t}\n\n\t\t\tlet result = this.getString(id, options);\n\t\t\tif (result) {\n\t\t\t\tif (this.encoding == 'json')\n\t\t\t\t\treturn JSON.parse(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\tgetEntry(id, options) {\n\t\t\tlet value = this.get(id, options);\n\t\t\tif (value !== undefined) {\n\t\t\t\tif (this.useVersions)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tversion: getLastVersion(),\n\t\t\t\t\t\t//size: this.lastSize\n\t\t\t\t\t};\n\t\t\t\telse\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t//size: this.lastSize\n\t\t\t\t\t};\n\t\t\t}\n\t\t},\n\t\tresetReadTxn() {\n\t\t\tresetReadTxn();\n\t\t},\n\t\t_commitReadTxn() {\n\t\t\tif (readTxn) {\n\t\t\t\treadTxn.isCommitted = true\n\t\t\t\treadTxn.commit();\n\t\t\t}\n\t\t\tlastReadTxnRef = null;\n\t\t\treadTxnRenewed = null;\n\t\t\treadTxn = null;\n\t\t},\n\t\tensureReadTxn() {\n\t\t\tif (!env.writeTxn && !readTxnRenewed)\n\t\t\t\trenewReadTxn(this);\n\t\t},\n\t\tdoesExist(key, versionOrValue) {\n\t\t\tif (versionOrValue == null) {\n\t\t\t\t// undefined means the entry exists, null is used specifically to check for the entry *not* existing\n\t\t\t\treturn (this.getBinaryFast(key) === undefined) == (versionOrValue === null);\n\t\t\t}\n\t\t\telse if (this.useVersions) {\n\t\t\t\treturn this.getBinaryFast(key) !== undefined && (versionOrValue === IF_EXISTS || getLastVersion() === versionOrValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (versionOrValue && versionOrValue['\\x10binary-data\\x02'])\n\t\t\t\t\tversionOrValue = versionOrValue['\\x10binary-data\\x02'];\n\t\t\t\telse if (this.encoder)\n\t\t\t\t\tversionOrValue = this.encoder.encode(versionOrValue);\n\t\t\t\tif (typeof versionOrValue == 'string')\n\t\t\t\t\tversionOrValue = Buffer.from(versionOrValue);\n\t\t\t\treturn this.getValuesCount(key, { start: versionOrValue, exactMatch: true}) > 0;\n\t\t\t}\n\t\t},\n\t\tgetValues(key, options) {\n\t\t\tlet defaultOptions = {\n\t\t\t\tkey,\n\t\t\t\tvaluesForKey: true\n\t\t\t};\n\t\t\tif (options && options.snapshot === false)\n\t\t\t\tthrow new Error('Can not disable snapshots for getValues');\n\t\t\treturn this.getRange(options ? Object.assign(defaultOptions, options) : defaultOptions);\n\t\t},\n\t\tgetKeys(options) {\n\t\t\tif (!options)\n\t\t\t\toptions = {};\n\t\t\toptions.values = false;\n\t\t\treturn this.getRange(options);\n\t\t},\n\t\tgetCount(options) {\n\t\t\tif (!options)\n\t\t\t\toptions = {};\n\t\t\toptions.onlyCount = true;\n\t\t\treturn this.getRange(options).iterate();\n\t\t},\n\t\tgetKeysCount(options) {\n\t\t\tif (!options)\n\t\t\t\toptions = {};\n\t\t\toptions.onlyCount = true;\n\t\t\toptions.values = false;\n\t\t\treturn this.getRange(options).iterate();\n\t\t},\n\t\tgetValuesCount(key, options) {\n\t\t\tif (!options)\n\t\t\t\toptions = {};\n\t\t\toptions.key = key;\n\t\t\toptions.valuesForKey = true;\n\t\t\toptions.onlyCount = true;\n\t\t\treturn this.getRange(options).iterate();\n\t\t},\n\t\tgetRange(options) {\n\t\t\tlet iterable = new RangeIterable();\n\t\t\tif (!options)\n\t\t\t\toptions = {};\n\t\t\tlet includeValues = options.values !== false;\n\t\t\tlet includeVersions = options.versions;\n\t\t\tlet valuesForKey = options.valuesForKey;\n\t\t\tlet limit = options.limit;\n\t\t\tlet db = this.db;\n\t\t\tlet snapshot = options.snapshot;\n\t\t\tlet compression = this.compression;\n\t\t\titerable.iterate = () => {\n\t\t\t\tlet currentKey = valuesForKey ? options.key : options.start;\n\t\t\t\tconst reverse = options.reverse;\n\t\t\t\tlet count = 0;\n\t\t\t\tlet cursor, cursorRenewId, cursorAddress;\n\t\t\t\tlet txn;\n\t\t\t\tlet flags = (includeValues ? 0x100 : 0) | (reverse ? 0x400 : 0) |\n\t\t\t\t\t(valuesForKey ? 0x800 : 0) | (options.exactMatch ? 0x4000 : 0) |\n\t\t\t\t\t(options.inclusiveEnd ? 0x8000 : 0) |\n\t\t\t\t\t(options.exclusiveStart ? 0x10000 : 0);\n\t\t\t\tlet store = this;\n\t\t\t\tfunction resetCursor() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (cursor)\n\t\t\t\t\t\t\tfinishCursor();\n\t\t\t\t\t\tlet txnAddress;\n\t\t\t\t\t\tif (options.transaction) {\n\t\t\t\t\t\t\ttxn = options.transaction;\n\t\t\t\t\t\t\ttxnAddress = txn.address;\n\t\t\t\t\t\t\tcursor = null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet writeTxn = env.writeTxn;\n\t\t\t\t\t\t\tif (writeTxn)\n\t\t\t\t\t\t\t\tsnapshot = false;\n\t\t\t\t\t\t\ttxn = env.writeTxn || options.transaction || (readTxnRenewed ? readTxn : renewReadTxn(store));\n\t\t\t\t\t\t\tcursor = !writeTxn && db.availableCursor;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cursor) {\n\t\t\t\t\t\t\tdb.availableCursor = null;\n\t\t\t\t\t\t\tflags |= 0x2000;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcursor = new Cursor(db, txnAddress || 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcursorAddress = cursor.address;\n\t\t\t\t\t\ttxn.refCount = (txn.refCount || 0) + 1; // track transaction so we always use the same one\n\t\t\t\t\t\tif (snapshot === false) {\n\t\t\t\t\t\t\tcursorRenewId = renewId; // use shared read transaction\n\t\t\t\t\t\t\ttxn.renewingRefCount = (txn.renewingRefCount || 0) + 1; // need to know how many are renewing cursors\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(error) {\n\t\t\t\t\t\tif (cursor) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tcursor.close();\n\t\t\t\t\t\t\t} catch(error) { }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresetCursor();\n\t\t\t\tif (options.onlyCount) {\n\t\t\t\t\tflags |= 0x1000;\n\t\t\t\t\tlet count = position(options.offset);\n\t\t\t\t\tif (count < 0)\n\t\t\t\t\t\tlmdbError(count);\n\t\t\t\t\tfinishCursor();\n\t\t\t\t\treturn count;\n\t\t\t\t}\n\t\t\t\tfunction position(offset) {\n\t\t\t\t\tlet keySize = currentKey === undefined ? 0 : store.writeKey(currentKey, keyBytes, 0);\n\t\t\t\t\tlet endAddress;\n\t\t\t\t\tif (valuesForKey) {\n\t\t\t\t\t\tif (options.start === undefined && options.end === undefined)\n\t\t\t\t\t\t\tendAddress = 0;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlet startAddress;\n\t\t\t\t\t\t\tif (store.encoder.writeKey) {\n\t\t\t\t\t\t\t\tstartAddress = saveKey(options.start, store.encoder.writeKey, iterable, maxKeySize);\n\t\t\t\t\t\t\t\tkeyBytesView.setFloat64(START_ADDRESS_POSITION, startAddress, true);\n\t\t\t\t\t\t\t\tendAddress = saveKey(options.end, store.encoder.writeKey, iterable, maxKeySize);\n\t\t\t\t\t\t\t} else if ((!options.start || options.start instanceof Uint8Array) && (!options.end || options.end instanceof Uint8Array)) {\n\t\t\t\t\t\t\t\tstartAddress = saveKey(options.start, orderedBinary.writeKey, iterable, maxKeySize);\n\t\t\t\t\t\t\t\tkeyBytesView.setFloat64(START_ADDRESS_POSITION, startAddress, true);\n\t\t\t\t\t\t\t\tendAddress = saveKey(options.end, orderedBinary.writeKey, iterable, maxKeySize);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthrow new Error('Only key-based encoding is supported for start/end values');\n\t\t\t\t\t\t\t\tlet encoded = store.encoder.encode(options.start);\n\t\t\t\t\t\t\t\tlet bufferAddress = encoded.buffer.address || (encoded.buffer.address = getAddress(encoded.buffer) - encoded.byteOffset);\n\t\t\t\t\t\t\t\tstartAddress = bufferAddress + encoded.byteOffset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tendAddress = saveKey(options.end, store.writeKey, iterable, maxKeySize);\n\t\t\t\t\treturn doPosition(cursorAddress, flags, offset || 0, keySize, endAddress);\n\t\t\t\t}\n\n\t\t\t\tfunction finishCursor() {\n\t\t\t\t\tif (txn.isDone)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif (iterable.onDone)\n\t\t\t\t\t\titerable.onDone()\n\t\t\t\t\tif (cursorRenewId)\n\t\t\t\t\t\ttxn.renewingRefCount--;\n\t\t\t\t\tif (--txn.refCount <= 0 && txn.notCurrent) {\n\t\t\t\t\t\tcursor.close();\n\t\t\t\t\t\ttxn.abort(); // this is no longer main read txn, abort it now that we are done\n\t\t\t\t\t\ttxn.isDone = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (db.availableCursor || txn != readTxn) {\n\t\t\t\t\t\t\tcursor.close();\n\t\t\t\t\t\t} else { // try to reuse it\n\t\t\t\t\t\t\tdb.availableCursor = cursor;\n\t\t\t\t\t\t\tdb.cursorTxn = txn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tnext() {\n\t\t\t\t\t\tlet keySize, lastSize;\n\t\t\t\t\t\tif (cursorRenewId && (cursorRenewId != renewId || txn.isDone)) {\n\t\t\t\t\t\t\tresetCursor();\n\t\t\t\t\t\t\tkeySize = position(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (count === 0) { // && includeValues) // on first entry, get current value if we need to\n\t\t\t\t\t\t\tkeySize = position(options.offset);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tkeySize = iterate(cursorAddress);\n\t\t\t\t\t\tif (keySize <= 0 ||\n\t\t\t\t\t\t\t\t(count++ >= limit)) {\n\t\t\t\t\t\t\tif (count < 0)\n\t\t\t\t\t\t\t\tlmdbError(count);\n\t\t\t\t\t\t\tfinishCursor();\n\t\t\t\t\t\t\treturn ITERATOR_DONE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valuesForKey || snapshot === false) {\n\t\t\t\t\t\t\tif (keySize > 20000) {\n\t\t\t\t\t\t\t\tif (keySize > 0x1000000)\n\t\t\t\t\t\t\t\t\tlmdbError(keySize - 0x100000000)\n\t\t\t\t\t\t\t\tthrow new Error('Invalid key size ' + keySize.toString(16))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcurrentKey = store.readKey(keyBytes, 32, keySize + 32);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (includeValues) {\n\t\t\t\t\t\t\tlet value;\n\t\t\t\t\t\t\tlastSize = keyBytesView.getUint32(0, true);\n\t\t\t\t\t\t\tlet bufferId = keyBytesView.getUint32(4, true);\n\t\t\t\t\t\t\tlet bytes;\n\t\t\t\t\t\t\tif (bufferId) {\n\t\t\t\t\t\t\t\tbytes = getMMapBuffer(bufferId, lastSize);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbytes = compression ? compression.getValueBytes : getValueBytes;\n\t\t\t\t\t\t\t\tif (lastSize > bytes.maxLength) {\n\t\t\t\t\t\t\t\t\tstore.lastSize = lastSize;\n\t\t\t\t\t\t\t\t\tasSafeBuffer = store.encoding == 'binary';\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tbytes = store._returnLargeBuffer(() => getCurrentValue(cursorAddress));\n\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\tasSafeBuffer = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\tbytes.length = lastSize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (store.decoder) {\n\t\t\t\t\t\t\t\tvalue = store.decoder.decode(bytes, lastSize);\n\t\t\t\t\t\t\t} else if (store.encoding == 'binary')\n\t\t\t\t\t\t\t\tvalue = bytes.isGlobal ? Uint8ArraySlice.call(bytes, 0, lastSize) : bytes;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tvalue = bytes.toString('utf8', 0, lastSize);\n\t\t\t\t\t\t\t\tif (store.encoding == 'json' && value)\n\t\t\t\t\t\t\t\t\tvalue = JSON.parse(value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (includeVersions)\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\tkey: currentKey,\n\t\t\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t\t\t\tversion: getLastVersion()\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n \t\t\t\t\t\t\telse if (valuesForKey)\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tvalue\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\tkey: currentKey,\n\t\t\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else if (includeVersions) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\tkey: currentKey,\n\t\t\t\t\t\t\t\t\tversion: getLastVersion()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tvalue: currentKey\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\treturn() {\n\t\t\t\t\t\tfinishCursor();\n\t\t\t\t\t\treturn ITERATOR_DONE;\n\t\t\t\t\t},\n\t\t\t\t\tthrow() {\n\t\t\t\t\t\tfinishCursor();\n\t\t\t\t\t\treturn ITERATOR_DONE;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t\treturn iterable;\n\t\t},\n\n\t\tgetMany(keys, callback) {\n\t\t\t// this is an asynchronous get for multiple keys. It actually works by prefetching asynchronously,\n\t\t\t// allowing a separate to absorb the potentially largest cost: hard page faults (and disk I/O).\n\t\t\t// And then we just do standard sync gets (to deserialized data) to fulfil the callback/promise\n\t\t\t// once the prefetch occurs\n\t\t\tlet promise = callback ? undefined : new Promise(resolve => callback = (error, results) => resolve(results));\n\t\t\tthis.prefetch(keys, () => {\n\t\t\t\tlet results = new Array(keys.length);\n\t\t\t\tfor (let i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\tresults[i] = get.call(this, keys[i]);\n\t\t\t\t}\n\t\t\t\tcallback(null, results);\n\t\t\t});\n\t\t\treturn promise;\n\t\t},\n\t\tgetSharedBufferForGet(id, options) {\n\t\t\tlet txn = env.writeTxn || (options && options.transaction) || (readTxnRenewed ? readTxn : renewReadTxn(this));\n\t\t\tthis.lastSize = this.keyIsCompatibility ? txn.getBinaryShared(id) : this.db.get(this.writeKey(id, keyBytes, 0));\n\t\t\tif (this.lastSize === -30798) { // not found code\n\t\t\t\treturn; //undefined\n\t\t\t}\n\t\t\treturn this.lastSize;\n\t\t\tthis.lastSize = keyBytesView.getUint32(0, true);\n\t\t\tlet bufferIndex = keyBytesView.getUint32(12, true);\n\t\t\tlastOffset = keyBytesView.getUint32(8, true);\n\t\t\tlet buffer = buffers[bufferIndex];\n\t\t\tlet startOffset;\n\t\t\tif (!buffer || lastOffset < (startOffset = buffer.startOffset) || (lastOffset + this.lastSize > startOffset + 0x100000000)) {\n\t\t\t\tif (buffer)\n\t\t\t\t\tenv.detachBuffer(buffer.buffer);\n\t\t\t\tstartOffset = (lastOffset >>> 16) * 0x10000;\n\t\t\t\tconsole.log('make buffer for address', bufferIndex * 0x100000000 + startOffset);\n\t\t\t\tbuffer = buffers[bufferIndex] = Buffer.from(getBufferForAddress(bufferIndex * 0x100000000 + startOffset));\n\t\t\t\tbuffer.startOffset = startOffset;\n\t\t\t}\n\t\t\tlastOffset -= startOffset;\n\t\t\treturn buffer;\n\t\t\treturn buffer.slice(lastOffset, lastOffset + this.lastSize);/*Uint8ArraySlice.call(buffer, lastOffset, lastOffset + this.lastSize)*/\n\t\t},\n\t\tprefetch(keys, callback) {\n\t\t\tif (!keys)\n\t\t\t\tthrow new Error('An array of keys must be provided');\n\t\t\tif (!keys.length) {\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(null);\n\t\t\t\t\treturn;\n\t\t\t\t} else\n\t\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\t\t\tlet buffers = [];\n\t\t\tlet startPosition;\n\t\t\tlet bufferHolder = {};\n\t\t\tlet lastBuffer;\n\t\t\tfor (let key of keys) {\n\t\t\t\tlet position\n\t\t\t\tif (key && key.key !== undefined && key.value !== undefined) {\n\t\t\t\t\tposition = saveKey(key.value, this.writeKey, bufferHolder, maxKeySize, 0x80000000);\n\t\t\t\t\tsaveKey(key.key, this.writeKey, bufferHolder, maxKeySize);\n\t\t\t\t} else {\n\t\t\t\t\tposition = saveKey(key, this.writeKey, bufferHolder, maxKeySize);\n\t\t\t\t}\n\t\t\t\tif (!startPosition)\n\t\t\t\t\tstartPosition = position;\n\t\t\t\tif (bufferHolder.saveBuffer != lastBuffer) {\n\t\t\t\t\tbuffers.push(bufferHolder);\n\t\t\t\t\tlastBuffer = bufferHolder.saveBuffer;\n\t\t\t\t\tbufferHolder = { saveBuffer: lastBuffer };\n\t\t\t\t}\n\t\t\t}\n\t\t\tsaveKey(undefined, this.writeKey, bufferHolder, maxKeySize);\n\t\t\toutstandingReads++;\n\t\t\tprefetch(this.dbAddress, startPosition, (error) => {\n\t\t\t\toutstandingReads--;\n\t\t\t\tif (error)\n\t\t\t\t\tconsole.error('Error with prefetch', buffers, bufferHolder); // partly exists to keep the buffers pinned in memory\n\t\t\t\telse\n\t\t\t\t\tcallback(null);\n\t\t\t});\n\t\t\tif (!callback)\n\t\t\t\treturn new Promise(resolve => callback = resolve);\n\t\t},\n\t\tuseReadTransaction() {\n\t\t\tlet txn = readTxnRenewed ? readTxn : renewReadTxn(this);\n\t\t\ttxn.use();\n\t\t\treturn txn;\n\t\t},\n\t\tclose(callback) {\n\t\t\tthis.status = 'closing';\n\t\t\tlet txnPromise;\n\t\t\tif (this.isRoot) {\n\t\t\t\t// if it is root, we need to abort and/or wait for transactions to finish\n\t\t\t\tif (readTxn) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treadTxn.abort();\n\t\t\t\t\t} catch(error) {}\n\t\t\t\t}\n\t\t\t\treadTxn = {\n\t\t\t\t\trenew() {\n\t\t\t\t\t\tthrow new Error('Can not read from a closed database');\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\treadTxnRenewed = null;\n\t\t\t\ttxnPromise = this._endWrites && this._endWrites();\n\t\t\t}\n\t\t\tconst doClose = () => {\n\t\t\t\tif (this.isRoot) {\n\t\t\t\t\tif (outstandingReads > 0) {\n\t\t\t\t\t\treturn new Promise(resolve => setTimeout(() => resolve(doClose()), 1));\n\t\t\t\t\t}\n\t\t\t\t\tenv.close();\n\t\t\t\t} else\n\t\t\t\t\tthis.db.close();\n\t\t\t\tthis.status = 'closed';\n\t\t\t\tif (callback)\n\t\t\t\t\tcallback();\n\t\t\t}\n\t\t\tif (txnPromise)\n\t\t\t\treturn txnPromise.then(doClose);\n\t\t\telse {\n\t\t\t\tdoClose();\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\t\t},\n\t\tgetStats() {\n\t\t\tlet txn = env.writeTxn || (readTxnRenewed ? readTxn : renewReadTxn(this));\n\t\t\tlet dbStats = this.db.stat();\n\t\t\tdbStats.root = env.stat();\n\t\t\tObject.assign(dbStats, env.info());\n\t\t\tdbStats.free = env.freeStat();\n\t\t\treturn dbStats;\n\t\t},\n\t});\n\tlet get = LMDBStore.prototype.get;\n\tlet lastReadTxnRef;\n\tfunction getMMapBuffer(bufferId, size) {\n\t\tlet buffer = mmaps[bufferId];\n\t\tif (!buffer) {\n\t\t\tbuffer = mmaps[bufferId] = getSharedBuffer(bufferId, env.address);\n\t\t}\n\t\tlet offset = keyBytesView.getUint32(8, true);\n\t\treturn new Uint8Array(buffer, offset, size);\n\t}\n\tfunction renewReadTxn(store) {\n\t\tif (!readTxn) {\n\t\t\tlet retries = 0;\n\t\t\tlet waitArray;\n\t\t\tdo {\n\t\t\t\ttry {\n\t\t\t\t\tlet lastReadTxn = lastReadTxnRef && lastReadTxnRef.deref();\n\t\t\t\t\treadTxn = new Txn(env, 0x20000, lastReadTxn && !lastReadTxn.isDone && lastReadTxn);\n\t\t\t\t\tif (readTxn.address == 0) {\n\t\t\t\t\t\treadTxn = lastReadTxn;\n\t\t\t\t\t\tif (readTxn.notCurrent)\n\t\t\t\t\t\t\treadTxn.notCurrent = false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (error.message.includes('temporarily')) {\n\t\t\t\t\t\tif (!waitArray)\n\t\t\t\t\t\t\twaitArray = new Int32Array(new SharedArrayBuffer(4), 0, 1);\n\t\t\t\t\t\tAtomics.wait(waitArray, 0, 0, retries * 2);\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t} while (retries++ < 100);\n\t\t}\n\t\t// we actually don't renew here, we let the renew take place in the next \n\t\t// lmdb native read/call so as to avoid an extra native call\n\t\treadTxnRenewed = setTimeout(resetReadTxn, 0);\n\t\tstore.emit('begin-transaction');\n\t\treturn readTxn;\n\t}\n\tfunction resetReadTxn() {\n\t\trenewId++;\n\t\tif (readTxnRenewed) {\n\t\t\treadTxnRenewed = null;\n\t\t\tif (readTxn.refCount - (readTxn.renewingRefCount || 0) > 0) {\n\t\t\t\treadTxn.notCurrent = true;\n\t\t\t\tlastReadTxnRef = new WeakRef(readTxn);\n\t\t\t\treadTxn = null;\n\t\t\t} else {\n\t\t\t\tresetTxn(readTxn.address);\n\t\t\t}\n\t\t}\n\t}\n}\nexport function makeReusableBuffer(size) {\n\tlet bytes = typeof Buffer != 'undefined' ? Buffer.alloc(size) : new Uint8Array(size);\n\tbytes.maxLength = size;\n\tObject.defineProperty(bytes, 'length', { value: size, writable: true, configurable: true });\n\treturn bytes;\n}\n\nTxn.prototype.done = function() {\n\tthis.refCount--;\n\tif (this.refCount === 0 && this.notCurrent) {\n\t\tthis.abort();\n\t\tthis.isDone = true;\n\t}\n}\nTxn.prototype.use = function() {\n\tthis.refCount = (this.refCount || 0) + 1;\n}\n\n\nlet readInstructions, readCallbacks = new Map(), uint32Instructions, instructionsDataView = { setFloat64() {}, setUint32() {} }, instructionsAddress;\nlet savePosition = 8000;\nlet DYNAMIC_KEY_BUFFER_SIZE = 8192;\nfunction allocateInstructionsBuffer() {\n\treadInstructions = typeof Buffer != 'undefined' ? Buffer.alloc(DYNAMIC_KEY_BUFFER_SIZE) : new Uint8Array(DYNAMIC_KEY_BUFFER_SIZE);\n\tuint32Instructions = new Int32Array(readInstructions.buffer, 0, readInstructions.buffer.byteLength >> 2);\n\tuint32Instructions[2] = 0xf0000000; // indicates a new read task must be started\n\tinstructionsAddress = readInstructions.buffer.address = getAddress(readInstructions.buffer);\n\treadInstructions.dataView = instructionsDataView = new DataView(readInstructions.buffer, readInstructions.byteOffset, readInstructions.byteLength);\n\tsavePosition = 0;\n}\nexport function recordReadInstruction(txnAddress, dbi, key, writeKey, maxKeySize, callback) {\n\tif (savePosition > 7800) {\n\t\tallocateInstructionsBuffer();\n\t}\n\tlet start = savePosition;\n\tlet keyPosition = savePosition + 16;\n\ttry {\n\t\tsavePosition = key === undefined ? keyPosition :\n\t\t\twriteKey(key, readInstructions, keyPosition);\n\t} catch (error) {\n\t\tif (error.name == 'RangeError') {\n\t\t\tif (8180 - start < maxKeySize) {\n\t\t\t\tallocateInstructionsBuffer(); // try again:\n\t\t\t\treturn recordReadInstruction(txnAddress, dbi, key, writeKey, maxKeySize, callback);\n\t\t\t}\n\t\t\tthrow new Error('Key was too large, max key size is ' + maxKeySize);\n\t\t} else\n\t\t\tthrow error;\n\t}\n\tlet length = savePosition - keyPosition;\n\tif (length > maxKeySize) {\n\t\tsavePosition = start;\n\t\tthrow new Error('Key of size ' + length + ' was too large, max key size is ' + maxKeySize);\n\t}\n\tuint32Instructions[(start >> 2) + 3] = length; // save the length\n\tuint32Instructions[(start >> 2) + 2] = dbi;\n\tsavePosition = (savePosition + 12) & 0xfffffc;\n\tinstructionsDataView.setFloat64(start, txnAddress, true);\n\tlet callbackId = addReadCallback(() => {\n\t\tlet position = start >> 2;\n\t\tlet rc = thisInstructions[position];\n\t\tcallback(rc, thisInstructions[position + 1], thisInstructions[position + 2], thisInstructions[position + 3]);\n\t});\n\tlet thisInstructions = uint32Instructions;\n\t//if (start === 0)\n\t\treturn startRead(instructionsAddress + start, callbackId, {}, 'read');\n\t//else\n\t\t//nextRead(start);\n}\nlet nextCallbackId = 0;\nlet addReadCallback = globalThis.__lmdb_read_callback;\nif (!addReadCallback) {\n\taddReadCallback = globalThis.__lmdb_read_callback = function(callback) {\n\t\tlet callbackId = nextCallbackId++;\n\t\treadCallbacks.set(callbackId, callback);\n\t\treturn callbackId;\n\t};\n\tsetReadCallback(function(callbackId) {\n\t\treadCallbacks.get(callbackId)();\n\t\treadCallbacks.delete(callbackId);\n\t})\n}\n","import { WeakLRUCache, clearKeptObjects } from './native.js';\nimport { FAILED_CONDITION, ABORT } from './write.js';\nimport { UNMODIFIED } from './read.js';\nimport { when } from './util/when.js';\n\nlet getLastVersion, getLastTxnId;\nconst mapGet = Map.prototype.get;\nexport const CachingStore = (Store, env) => {\n\tlet childTxnChanges\n\treturn class LMDBStore extends Store {\n\tconstructor(dbName, options) {\n\t\tsuper(dbName, options);\n\t\tif (!env.cacheCommitter) {\n\t\t\tenv.cacheCommitter = true;\n\t\t\tthis.on('aftercommit', ({ next, last, txnId }) => {\n\t\t\t\tdo {\n\t\t\t\t\tlet meta = next.meta;\n\t\t\t\t\tlet store = meta && meta.store;\n\t\t\t\t\tif (store) {\n\t\t\t\t\t\tif (next.flag & FAILED_CONDITION)\n\t\t\t\t\t\t\tstore.cache.delete(meta.key); // just delete it from the map\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlet expirationPriority = meta.valueSize >> 10;\n\t\t\t\t\t\t\tlet cache = store.cache;\n\t\t\t\t\t\t\tlet entry = mapGet.call(cache, meta.key);\n\t\t\t\t\t\t\tif (entry) {\n\t\t\t\t\t\t\t\tentry.txnId = txnId;\n\t\t\t\t\t\t\t\tcache.used(entry, expirationPriority + 4); // this will enter it into the LRFU (with a little lower priority than a read)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (next != last && (next = next.next))\n\t\t\t});\n\t\t}\n\t\tthis.db.cachingDb = this;\n\t\tif (options.cache.clearKeptInterval)\n\t\t\toptions.cache.clearKeptObjects = clearKeptObjects;\n\t\tthis.cache = new WeakLRUCache(options.cache);\n\t\tif (options.cache.validated)\n\t\t\tthis.cache.validated = true;\n\t}\n\tget isCaching() {\n\t\treturn true\n\t}\n\tget(id, options) {\n\t\tlet value;\n\t\tif (this.cache.validated) {\n\t\t\tlet entry = this.cache.get(id);\n\t\t\tif (entry) {\n\t\t\t\tlet cachedValue = entry.value;\n\t\t\t\tif (entry.txnId != null) {\n\t\t\t\t\tvalue = super.get(id, { ifNotTxnId: entry.txnId, transaction: options && options.transaction });\n\t\t\t\t\tif (value === UNMODIFIED)\n\t\t\t\t\t\treturn cachedValue;\n\t\t\t\t} else // with no txn id we do not validate; this is the state of a cached value after a write before it transacts\n\t\t\t\t\treturn cachedValue;\n\t\t\t} else\n\t\t\t\tvalue = super.get(id, options);\n\t\t} else if (options && options.transaction) {\n\t\t\treturn super.get(id, options);\n\t\t}\telse {\n\t\t\tvalue = this.cache.getValue(id);\n\t\t\tif (value !== undefined) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tvalue = super.get(id);\n\t\t}\n\t\tif (value && typeof value === 'object' && !options && typeof id !== 'object') {\n\t\t\tlet entry = this.cache.setValue(id, value, this.lastSize >> 10);\n\t\t\tif (this.useVersions) {\n\t\t\t\tentry.version = getLastVersion();\n\t\t\t}\n\t\t\tif (this.cache.validated)\n\t\t\t\tentry.txnId = getLastTxnId();\n\t\t}\n\t\treturn value;\n\t}\n\tgetEntry(id, cacheMode) {\n\t\tlet entry = this.cache.get(id);\n\t\tif (entry)\n\t\t\treturn entry;\n\t\tlet value = super.get(id);\n\t\tif (value === undefined)\n\t\t\treturn;\n\t\tif (value && typeof value === 'object' && !cacheMode && typeof id !== 'object') {\n\t\t\tentry = this.cache.setValue(id, value, this.lastSize >> 10);\n\t\t} else {\n\t\t\tentry = { value };\n\t\t}\n\t\tif (this.useVersions) {\n\t\t\tentry.version = getLastVersion();\n\t\t}\n\t\treturn entry;\n\t}\n\tputEntry(id, entry, ifVersion) {\n\t\tlet result = super.put(id, entry.value, entry.version, ifVersion);\n\t\tif (typeof id === 'object')\n\t\t\treturn result;\n\t\tif (result && result.then)\n\t\t\tthis.cache.setManually(id, entry); // set manually so we can keep it pinned in memory until it is committed\n\t\telse // sync operation, immediately add to cache\n\t\t\tthis.cache.set(id, entry);\n\t}\n\tput(id, value, version, ifVersion) {\n\t\tlet result = super.put(id, value, version, ifVersion);\n\t\tif (typeof id !== 'object') {\n\t\t\tif (value && value['\\x10binary-data\\x02']) {\n\t\t\t\t// don't cache binary data, since it will be decoded on get\n\t\t\t\tthis.cache.delete(id);\n\t\t\t\treturn result;\n\t\t\t}\t\n\t\t\t// sync operation, immediately add to cache, otherwise keep it pinned in memory until it is committed\n\t\t\tlet entry = this.cache.setValue(id, value, !result || result.isSync ? 0 : -1);\n\t\t\tif (childTxnChanges)\n\t\t\t\tchildTxnChanges.add(id);\n\t\t\tif (version !== undefined)\n\t\t\t\tentry.version = typeof version === 'object' ? version.version : version;\n\t\t}\n\t\treturn result;\n\t}\n\tputSync(id, value, version, ifVersion) {\n\t\tif (id !== 'object') {\n\t\t\t// sync operation, immediately add to cache, otherwise keep it pinned in memory until it is committed\n\t\t\tif (value && typeof value === 'object') {\n\t\t\t\tlet entry = this.cache.setValue(id, value);\n\t\t\t\tif (childTxnChanges)\n\t\t\t\t\tchildTxnChanges.add(id);\n\t\t\t\tif (version !== undefined) {\n\t\t\t\t\tentry.version = typeof version === 'object' ? version.version : version;\n\t\t\t\t}\n\t\t\t} else // it is possible that  a value used to exist here\n\t\t\t\tthis.cache.delete(id);\n\t\t}\n\t\treturn super.putSync(id, value, version, ifVersion);\n\t}\n\tremove(id, ifVersion) {\n\t\tthis.cache.delete(id);\n\t\treturn super.remove(id, ifVersion);\n\t}\n\tremoveSync(id, ifVersion) {\n\t\tthis.cache.delete(id);\n\t\treturn super.removeSync(id, ifVersion);\n\t}\n\tclearAsync(callback) {\n\t\tthis.cache.clear();\n\t\treturn super.clearAsync(callback);\n\t}\n\tclearSync() {\n\t\tthis.cache.clear();\n\t\tsuper.clearSync();\n\t}\n\tchildTransaction(callback) {\n\t\treturn super.childTransaction(() => {\n\t\t\tlet cache = this.cache;\n\t\t\tlet previousChanges = childTxnChanges;\n\t\t\ttry {\n\t\t\t\tchildTxnChanges = new Set();\n\t\t\t\treturn when(callback(), (result) => {\n\t\t\t\t\tif (result === ABORT)\n\t\t\t\t\t\treturn abort();\n\t\t\t\t\tchildTxnChanges = previousChanges;\n\t\t\t\t\treturn result;\n\t\t\t\t}, abort);\n\t\t\t} catch(error) {\n\t\t\t\tabort(error);\n\t\t\t}\n\t\t\tfunction abort(error) {\n\t\t\t\t// if the transaction was aborted, remove all affected entries from cache\n\t\t\t\tfor (let id of childTxnChanges)\n\t\t\t\t\tcache.delete(id);\n\t\t\t\tchildTxnChanges = previousChanges;\n\t\t\t\tif (error)\n\t\t\t\t\tthrow error;\n\t\t\t\telse\n\t\t\t\t\treturn ABORT;\n\t\t\t}\n\t\t});\n\t}\n\t};\n};\nexport function setGetLastVersion(get, getTxnId) {\n\tgetLastVersion = get;\n\tgetLastTxnId = getTxnId;\n}\n","import { Compression, getAddress, arch, fs, path as pathModule, lmdbError, EventEmitter, MsgpackrEncoder, Env,\n\tDbi, tmpdir, os, nativeAddon } from './native.js';\nimport { CachingStore, setGetLastVersion } from './caching.js';\nimport { addReadMethods, makeReusableBuffer } from './read.js';\nimport { addWriteMethods } from './write.js';\nimport { applyKeyHandling } from './keys.js';\nlet moduleRequire = typeof require == 'function' && require;\nexport function setRequire(require) {\n\tmoduleRequire = require;\n}\n\nsetGetLastVersion(getLastVersion, getLastTxnId);\nlet keyBytes, keyBytesView;\nconst buffers = [];\nconst { onExit, getEnvsPointer, setEnvsPointer, getEnvFlags, setJSFlags } = nativeAddon;\nif (globalThis.__lmdb_envs__)\n\tsetEnvsPointer(globalThis.__lmdb_envs__);\nelse\n\tglobalThis.__lmdb_envs__ = getEnvsPointer();\n\n// this is hard coded as an upper limit because it is important assumption of the fixed buffers in writing instructions\n// this corresponds to the max key size for 8KB pages\nconst MAX_KEY_SIZE = 4026;\n// this is used as the key size by default because default page size is OS page size, which is usually\n// 4KB (but is 16KB on M-series MacOS), and this keeps a consistent max key size when no page size specified.\nconst DEFAULT_MAX_KEY_SIZE = 1978;\nconst DEFAULT_COMMIT_DELAY = 0;\n\nexport const allDbs = new Map();\nlet defaultCompression;\nlet lastSize;\nlet hasRegisteredOnExit;\nexport function open(path, options) {\n\tif (nativeAddon.open) {\n\t\tif (nativeAddon.open !== open) {\n\t\t\t// this is the case when lmdb-js has been opened in both ESM and CJS mode, which means that there are two\n\t\t\t// separate JS modules, but they are both using the same native module.\n\t\t\tgetLastVersion = nativeAddon.getLastVersion;\n\t\t\tgetLastTxnId = nativeAddon.getLastTxnId;\n\t\t\tsetGetLastVersion(getLastVersion, getLastTxnId);\n\t\t\treturn nativeAddon.open(path, options);\n\t\t}\n\t} else {\n\t\tnativeAddon.open = open;\n\t\tnativeAddon.getLastVersion = getLastVersion;\n\t\tnativeAddon.getLastTxnId = getLastTxnId;\n\t}\n\tif (!keyBytes) // TODO: Consolidate get buffer and key buffer (don't think we need both)\n\t\tallocateFixedBuffer();\n\tif (typeof path == 'object' && !options) {\n\t\toptions = path;\n\t\tpath = options.path;\n\t}\n\toptions = options || {};\n\tlet userOptions = options;\n\tif (!path) {\n\t\toptions = Object.assign({\n\t\t\tdeleteOnClose: true,\n\t\t\tnoSync: true,\n\t\t}, options);\n\t\tpath = tmpdir() + '/' + Math.floor(Math.random() * 2821109907455).toString(36) + '.mdb'\n\t} else if (!options)\n\t\toptions = {};\n\tlet extension = pathModule.extname(path);\n\tlet name = pathModule.basename(path, extension);\n\tlet is32Bit = arch().endsWith('32');\n\tlet remapChunks = options.remapChunks || options.encryptionKey || (options.mapSize ?\n\t\t(is32Bit && options.mapSize > 0x100000000) : // larger than fits in address space, must use dynamic maps\n\t\tis32Bit); // without a known map size, we default to being able to handle large data correctly/well*/\n\tlet userMapSize = options.mapSize;\n\toptions = Object.assign({\n\t\tpath,\n\t\tnoSubdir: Boolean(extension),\n\t\tisRoot: true,\n\t\tmaxDbs: 12,\n\t\tremapChunks,\n\t\tkeyBytes,\n\t\toverlappingSync: (options.noSync || options.readOnly) ? false : (os != 'win32'),\n\t\t// default map size limit of 4 exabytes when using remapChunks, since it is not preallocated and we can\n\t\t// make it super huge.\n\t\tmapSize: remapChunks ? 0x10000000000000 :\n\t\t\t0x20000, // Otherwise we start small with 128KB\n\t\tsafeRestore: process.env.LMDB_RESTORE == 'safe',\n\t}, options);\n\tif (options.asyncTransactionOrder == 'strict') {\n\t\toptions.strictAsyncOrder = true;\n\t}\n\tif (nativeAddon.version.major + nativeAddon.version.minor / 100 + nativeAddon.version.patch / 10000 < 0.0980) {\n\t\toptions.overlappingSync = false; // not support on older versions\n\t\toptions.trackMetrics = false;\n\t\toptions.usePreviousSnapshot = false;\n\t\toptions.safeRestore = false;\n\t\toptions.remapChunks = false;\n\t\tif (!userMapSize) options.mapSize = 0x40000000; // 1 GB\n\t}\n\n\tif (!exists(options.noSubdir ? pathModule.dirname(path) : path))\n\t\tfs.mkdirSync(options.noSubdir ? pathModule.dirname(path) : path, { recursive: true }\n\t\t);\n\tfunction makeCompression(compressionOptions) {\n\t\tif (compressionOptions instanceof Compression)\n\t\t\treturn compressionOptions;\n\t\tlet useDefault = typeof compressionOptions != 'object';\n\t\tif (useDefault && defaultCompression)\n\t\t\treturn defaultCompression;\n\t\tcompressionOptions = Object.assign({\n\t\t\tthreshold: 1000,\n\t\t\tdictionary: fs.readFileSync(new URL('./dict/dict.txt', import.meta.url.replace(/dist[\\\\\\/]index.cjs$/, ''))),\n\t\t\tgetValueBytes: makeReusableBuffer(0),\n\t\t}, compressionOptions);\n\t\tlet compression = Object.assign(new Compression(compressionOptions), compressionOptions);\n\t\tif (useDefault)\n\t\t\tdefaultCompression = compression;\n\t\treturn compression;\n\t}\n\n\tif (options.compression)\n\t\toptions.compression = makeCompression(options.compression);\n\tlet flags =\n\t\t(options.overlappingSync ? 0x1000 : 0) |\n\t\t(options.noSubdir ? 0x4000 : 0) |\n\t\t(options.noSync ? 0x10000 : 0) |\n\t\t(options.readOnly ? 0x20000 : 0) |\n\t\t(options.noMetaSync ? 0x40000 : 0) |\n\t\t(options.useWritemap ? 0x80000 : 0) |\n\t\t(options.mapAsync ? 0x100000 : 0) |\n\t\t(options.noReadAhead ? 0x800000 : 0) |\n\t\t(options.noMemInit ? 0x1000000 : 0) |\n\t\t(options.usePreviousSnapshot ? 0x2000000 : 0) |\n\t\t(options.remapChunks ? 0x4000000 : 0) |\n\t\t(options.safeRestore ? 0x800 : 0) |\n\t\t(options.trackMetrics ? 0x400 : 0);\n\n\tlet env = new Env();\n\tlet jsFlags = (options.overlappingSync ? 0x1000 : 0) |\n\t\t(options.separateFlushed ? 1 : 0) |\n\t\t(options.deleteOnClose ? 2 : 0);\n\tlet rc = env.open(options, flags, jsFlags);\n\tenv.path = path;\n   if (rc)\n\t\tlmdbError(rc);\n\tdelete options.keyBytes // no longer needed, don't copy to stores\n\tlet maxKeySize = env.getMaxKeySize();\n\tmaxKeySize = Math.min(maxKeySize, options.pageSize ? MAX_KEY_SIZE : DEFAULT_MAX_KEY_SIZE);\n\tflags = getEnvFlags(env.address); // re-retrieve them, they are not necessarily the same if we are connecting to an existing env\n\tif (flags & 0x1000) {\n\t\tif (userOptions.noSync) {\n\t\t\tenv.close();\n\t\t\tthrow new Error('Can not set noSync on a database that was opened with overlappingSync');\n\t\t}\n\t} else if (options.overlappingSync) {\n\t\tif (userOptions.overlappingSync) {\n\t\t\tenv.close();\n\t\t\tthrow new Error('Can not enable overlappingSync on a database that was opened without this flag');\n\t\t}\n\t\toptions.overlappingSync = false;\n\t\tjsFlags = jsFlags & 0xff; // clear overlapping sync\n\t\tsetJSFlags(env.address, jsFlags);\n\t}\n\n\tenv.readerCheck(); // clear out any stale entries\n\tif ((options.overlappingSync || options.deleteOnClose) && !hasRegisteredOnExit && process.on) {\n\t\thasRegisteredOnExit = true;\n\t\tprocess.on('exit', onExit);\n\t}\n\n\tclass LMDBStore extends EventEmitter {\n\t\tconstructor(dbName, dbOptions) {\n\t\t\tsuper();\n\t\t\tif (dbName === undefined)\n\t\t\t\tthrow new Error('Database name must be supplied in name property (may be null for root database)');\n\n\t\t\tif (options.compression && dbOptions.compression !== false && typeof dbOptions.compression != 'object')\n\t\t\t\tdbOptions.compression = options.compression; // use the parent compression if available\n\t\t\telse if (dbOptions.compression)\n\t\t\t\tdbOptions.compression = makeCompression(dbOptions.compression);\n\n\t\t\tif (dbOptions.dupSort && (dbOptions.useVersions || dbOptions.cache)) {\n\t\t\t\tthrow new Error('The dupSort flag can not be combined with versions or caching');\n\t\t\t}\n\t\t\tlet keyIsBuffer = dbOptions.keyIsBuffer\n\t\t\tif (dbOptions.keyEncoding == 'uint32') {\n\t\t\t\tdbOptions.keyIsUint32 = true;\n\t\t\t} else if (dbOptions.keyEncoder) {\n\t\t\t\tif (dbOptions.keyEncoder.enableNullTermination) {\n\t\t\t\t\tdbOptions.keyEncoder.enableNullTermination()\n\t\t\t\t} else\n\t\t\t\t\tkeyIsBuffer = true;\n\t\t\t} else if (dbOptions.keyEncoding == 'binary') {\n\t\t\t\tkeyIsBuffer = true;\n\t\t\t}\n\t\t\tlet flags = (dbOptions.reverseKey ? 0x02 : 0) |\n\t\t\t\t(dbOptions.dupSort ? 0x04 : 0) |\n\t\t\t\t(dbOptions.dupFixed ? 0x10 : 0) |\n\t\t\t\t(dbOptions.integerDup ? 0x20 : 0) |\n\t\t\t\t(dbOptions.reverseDup ? 0x40 : 0) |\n\t\t\t\t(!options.readOnly && dbOptions.create !== false ? 0x40000 : 0) |\n\t\t\t\t(dbOptions.useVersions ? 0x100 : 0);\n\t\t\tlet keyType = (dbOptions.keyIsUint32 || dbOptions.keyEncoding == 'uint32') ? 2 : keyIsBuffer ? 3 : 0;\n\t\t\tif (keyType == 2)\n\t\t\t\tflags |= 0x08; // integer key\n\n\t\t\tif (options.readOnly) {\n\t\t\t\t// in read-only mode we use a read-only txn to open the database\n\t\t\t\t// TODO: LMDB is actually not entirely thread-safe when it comes to opening databases with\n\t\t\t\t// read-only transactions since there is a race condition on setting the update dbis that\n\t\t\t\t// occurs outside the lock\n\t\t\t\t// make sure we are using a fresh read txn, so we don't want to share with a cursor txn\n\t\t\t\tthis.resetReadTxn();\n\t\t\t\tthis.ensureReadTxn();\n\t\t\t\tthis.db = new Dbi(env, flags, dbName, keyType, dbOptions.compression);\n\t\t\t} else {\n\t\t\t\tthis.transactionSync(() => {\n\t\t\t\t\tthis.db = new Dbi(env, flags, dbName, keyType, dbOptions.compression);\n\t\t\t\t}, options.overlappingSync ? 0x10002 : 2); // no flush-sync, but synchronously commit\n\t\t\t}\n\t\t\tthis._commitReadTxn(); // current read transaction becomes invalid after opening another db\n\t\t\tif (!this.db || this.db.dbi == 0xffffffff) {// not found\n\t\t\t\tthrow new Error('Database not found')\n\t\t\t}\n\t\t\tthis.dbAddress = this.db.address\n\t\t\tthis.db.name = dbName || null;\n\t\t\tthis.name = dbName;\n\t\t\tthis.status = 'open';\n\t\t\tthis.env = env;\n\t\t\tthis.reads = 0;\n\t\t\tthis.writes = 0;\n\t\t\tthis.transactions = 0;\n\t\t\tthis.averageTransactionTime = 5;\n\t\t\tif (dbOptions.syncBatchThreshold)\n\t\t\t\tconsole.warn('syncBatchThreshold is no longer supported');\n\t\t\tif (dbOptions.immediateBatchThreshold)\n\t\t\t\tconsole.warn('immediateBatchThreshold is no longer supported');\n\t\t\tthis.commitDelay = DEFAULT_COMMIT_DELAY;\n\t\t\tObject.assign(this, { // these are the options that are inherited\n\t\t\t\tpath: options.path,\n\t\t\t\tencoding: options.encoding,\n\t\t\t\tstrictAsyncOrder: options.strictAsyncOrder,\n\t\t\t}, dbOptions);\n\t\t\tlet Encoder;\n\t\t\tif (this.encoder && this.encoder.Encoder) {\n\t\t\t\tEncoder = this.encoder.Encoder;\n\t\t\t\tthis.encoder = null; // don't copy everything from the module\n\t\t\t}\n\t\t\tif (!Encoder && !(this.encoder && this.encoder.encode) && (!this.encoding || this.encoding == 'msgpack' || this.encoding == 'cbor')) {\n\t\t\t\tEncoder = (this.encoding == 'cbor' ? moduleRequire('cbor-x').Encoder : MsgpackrEncoder);\n\t\t\t}\n\t\t\tif (Encoder) {\n\t\t\t\tthis.encoder = new Encoder(Object.assign(\n\t\t\t\t\tassignConstrainedProperties(['copyBuffers', 'getStructures', 'saveStructures', 'useFloat32', 'useRecords', 'structuredClone', 'variableMapSize', 'useTimestamp32', 'largeBigIntToFloat', 'encodeUndefinedAsNil', 'int64AsNumber', 'onInvalidDate', 'mapsAsObjects', 'useTag259ForMaps', 'pack', 'maxSharedStructures', 'shouldShareStructure', 'randomAccessStructure', 'freezeData'],\n\t\t\t\t\tthis.sharedStructuresKey ? this.setupSharedStructures() : {\n\t\t\t\t\t\tcopyBuffers: true, // need to copy any embedded buffers that are found since we use unsafe buffers\n\t\t\t\t\t}, options, dbOptions), this.encoder));\n\t\t\t}\n\t\t\tif (this.encoding == 'json') {\n\t\t\t\tthis.encoder = {\n\t\t\t\t\tencode: JSON.stringify,\n\t\t\t\t};\n\t\t\t} else if (this.encoder) {\n\t\t\t\tthis.decoder = this.encoder;\n\t\t\t\tthis.decoderCopies = !this.encoder.needsStableBuffer\n\t\t\t}\n\t\t\tthis.maxKeySize = maxKeySize;\n\t\t\tapplyKeyHandling(this);\n\t\t\tallDbs.set(dbName ? name + '-' + dbName : name, this);\n\t\t}\n\t\topenDB(dbName, dbOptions) {\n\t\t\tif (this.dupSort && this.name == null)\n\t\t\t\tthrow new Error('Can not open named databases if the main database is dupSort')\n\t\t\tif (typeof dbName == 'object' && !dbOptions) {\n\t\t\t\tdbOptions = dbName;\n\t\t\t\tdbName = dbOptions.name;\n\t\t\t} else\n\t\t\t\tdbOptions = dbOptions || {};\n\t\t\ttry {\n\t\t\t\treturn dbOptions.cache ?\n\t\t\t\t\tnew (CachingStore(LMDBStore, env))(dbName, dbOptions) :\n\t\t\t\t\tnew LMDBStore(dbName, dbOptions);\n\t\t\t} catch(error) {\n\t\t\t\tif (error.message == 'Database not found')\n\t\t\t\t\treturn; // return undefined to indicate db not found\n\t\t\t\tif (error.message.indexOf('MDB_DBS_FULL') > -1) {\n\t\t\t\t\terror.message += ' (increase your maxDbs option)';\n\t\t\t\t}\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t\topen(dbOptions, callback) {\n\t\t\tlet db = this.openDB(dbOptions);\n\t\t\tif (callback)\n\t\t\t\tcallback(null, db);\n\t\t\treturn db;\n\t\t}\n\t\tbackup(path, compact) {\n\t\t\tfs.mkdirSync(pathModule.dirname(path), { recursive: true });\n\t\t\treturn new Promise((resolve, reject) => env.copy(path, false, (error) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t\tisOperational() {\n\t\t\treturn this.status == 'open';\n\t\t}\n\t\tsync(callback) {\n\t\t\treturn env.sync(callback || function(error) {\n\t\t\t\tif (error) {\n\t\t\t\t\tconsole.error(error);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tdeleteDB() {\n\t\t\tconsole.warn('deleteDB() is deprecated, use drop or dropSync instead');\n\t\t\treturn this.dropSync();\n\t\t}\n\t\tdropSync() {\n\t\t\tthis.transactionSync(() =>\n\t\t\t\tthis.db.drop({\n\t\t\t\t\tjustFreePages: false\n\t\t\t\t}), options.overlappingSync ? 0x10002 : 2);\n\t\t}\n\t\tclear(callback) {\n\t\t\tif (typeof callback == 'function')\n\t\t\t\treturn this.clearAsync(callback);\n\t\t\tconsole.warn('clear() is deprecated, use clearAsync or clearSync instead');\n\t\t\tthis.clearSync();\n\t\t}\n\t\tclearSync() {\n\t\t\tif (this.encoder) {\n\t\t\t\tif (this.encoder.clearSharedData)\n\t\t\t\t\tthis.encoder.clearSharedData()\n\t\t\t\telse if (this.encoder.structures)\n\t\t\t\t\tthis.encoder.structures = []\n\t\t\t}\n\t\t\tthis.transactionSync(() =>\n\t\t\t\tthis.db.drop({\n\t\t\t\t\tjustFreePages: true\n\t\t\t\t}), options.overlappingSync ? 0x10002 : 2);\n\t\t}\n\t\treaderCheck() {\n\t\t\treturn env.readerCheck();\n\t\t}\n\t\treaderList() {\n\t\t\treturn env.readerList().join('');\n\t\t}\n\t\tsetupSharedStructures() {\n\t\t\tconst getStructures = () => {\n\t\t\t\tlet lastVersion; // because we are doing a read here, we may need to save and restore the lastVersion from the last read\n\t\t\t\tif (this.useVersions)\n\t\t\t\t\tlastVersion = getLastVersion();\n\t\t\t\tlet buffer = this.getBinary(this.sharedStructuresKey);\n\t\t\t\tif (this.useVersions)\n\t\t\t\t\tsetLastVersion(lastVersion);\n\t\t\t\treturn buffer && this.decoder.decode(buffer);\n\t\t\t};\n\t\t\treturn {\n\t\t\t\tsaveStructures: (structures, isCompatible) => {\n\t\t\t\t\treturn this.transactionSync(() => {\n\t\t\t\t\t\tlet existingStructuresBuffer = this.getBinary(this.sharedStructuresKey);\n\t\t\t\t\t\tlet existingStructures = existingStructuresBuffer && this.decoder.decode(existingStructuresBuffer);\n\t\t\t\t\t\tif (typeof isCompatible == 'function' ?\n\t\t\t\t\t\t\t\t!isCompatible(existingStructures) :\n\t\t\t\t\t\t\t\t(existingStructures && existingStructures.length != isCompatible))\n\t\t\t\t\t\t\treturn false; // it changed, we need to indicate that we couldn't update\n\t\t\t\t\t\tthis.put(this.sharedStructuresKey, structures);\n\t\t\t\t\t},  options.overlappingSync ? 0x10000 : 0);\n\t\t\t\t},\n\t\t\t\tgetStructures,\n\t\t\t\tcopyBuffers: true, // need to copy any embedded buffers that are found since we use unsafe buffers\n\t\t\t};\n\t\t}\n\t}\n\t// if caching class overrides putSync, don't want to double call the caching code\n\tconst putSync = LMDBStore.prototype.putSync;\n\tconst removeSync = LMDBStore.prototype.removeSync;\n\taddReadMethods(LMDBStore, { env, maxKeySize, keyBytes, keyBytesView, getLastVersion });\n\tif (!options.readOnly)\n\t\taddWriteMethods(LMDBStore, { env, maxKeySize, fixedBuffer: keyBytes,\n\t\t\tresetReadTxn: LMDBStore.prototype.resetReadTxn, ...options });\n\tLMDBStore.prototype.supports = {\n\t\tpermanence: true,\n\t\tbufferKeys: true,\n\t\tpromises: true,\n\t\tsnapshots: true,\n\t\tclear: true,\n\t\tstatus: true,\n\t\tdeferredOpen: true,\n\t\topenCallback: true,\t\n\t};\n\tlet Class = options.cache ? CachingStore(LMDBStore, env) : LMDBStore;\n\treturn options.asClass ? Class : new Class(options.name || null, options);\n}\nexport function openAsClass(path, options) {\n\tif (typeof path == 'object' && !options) {\n\t\toptions = path;\n\t\tpath = options.path;\n\t}\n\toptions = options || {};\n\toptions.asClass = true;\n\treturn open(path, options);\n}\n\nexport function getLastVersion() {\n\treturn keyBytesView.getFloat64(16, true);\n}\nexport function setLastVersion(version) {\n\treturn keyBytesView.setFloat64(16, version, true);\n}\n\nexport function getLastTxnId() {\n\treturn keyBytesView.getUint32(32, true);\n}\n\nconst KEY_BUFFER_SIZE = 4096;\nfunction allocateFixedBuffer() {\n\tkeyBytes = typeof Buffer != 'undefined' ? Buffer.allocUnsafeSlow(KEY_BUFFER_SIZE) : new Uint8Array(KEY_BUFFER_SIZE);\n\tconst keyBuffer = keyBytes.buffer;\n\tkeyBytesView = keyBytes.dataView || (keyBytes.dataView = new DataView(keyBytes.buffer, 0, KEY_BUFFER_SIZE)); // max key size is actually 4026\n\tkeyBytes.uint32 = new Uint32Array(keyBuffer, 0, KEY_BUFFER_SIZE >> 2);\n\tkeyBytes.float64 = new Float64Array(keyBuffer, 0, KEY_BUFFER_SIZE >> 3);\n\tkeyBytes.uint32.address = keyBytes.address = keyBuffer.address = getAddress(keyBuffer);\n}\n\nfunction exists(path) {\n\tif (fs.existsSync)\n\t\treturn fs.existsSync(path);\n\ttry {\n\t\treturn fs.statSync(path);\n\t} catch (error) {\n\t\treturn false\n\t}\n}\n\nfunction assignConstrainedProperties(allowedProperties, target) {\n\tfor (let i = 2; i < arguments.length; i++) {\n\t\tlet source = arguments[i];\n\t\tfor (let key in source) {\n\t\t\tif (allowedProperties.includes(key))\n\t\t\t\ttarget[key] = source[key];\n\t\t}\n\t}\n\treturn target;\n}\n","import { createRequire } from 'module';\nimport { setRequire } from './open.js';\nimport { nativeAddon, setNativeFunctions } from './native.js';\nexport { nativeAddon } from './native.js'\nimport { setFlagsFromString } from 'v8';\nsetRequire(createRequire(import.meta.url));\nexport let v8AccelerationEnabled = false\n\nlet versions = process.versions;\nif (!versions.deno) {\n\tlet [ majorVersion, minorVersion ] = versions.node.split('.');\n\tif (versions.v8 && +majorVersion == nativeAddon.version.nodeCompiledVersion) {\n\t\tlet v8Funcs = {};\n\t\tlet fastApiCalls = (majorVersion == 17 || majorVersion == 18 || majorVersion == 16 && minorVersion > 8) && !process.env.DISABLE_TURBO_CALLS;\n\t\tif (fastApiCalls)\n\t\t\tsetFlagsFromString('--turbo-fast-api-calls')\n\t\tnativeAddon.enableDirectV8(v8Funcs, fastApiCalls);\n\t\tObject.assign(nativeAddon, v8Funcs);\n\t\tv8AccelerationEnabled = true;\n\t} else if (majorVersion == 14) {\n\t\t// node v14 only has ABI compatibility with node v16 for zero-arg clearKeptObjects\n\t\tlet v8Funcs = {};\n\t\tnativeAddon.enableDirectV8(v8Funcs, false);\n\t\tnativeAddon.clearKeptObjects = v8Funcs.clearKeptObjects;\n\t}\n\tnativeAddon.enableThreadSafeCalls();\n}\nsetNativeFunctions(nativeAddon);\n\nexport * from './index.js'\nexport { default } from './index.js'\n"],"names":["clearKeptObjects","pathModule","dirname","fileURLToPath","loadNAPI","REUSE_BUFFER_MODE","IF_EXISTS","Uint8ArraySlice","savePosition","DYNAMIC_KEY_BUFFER_SIZE","orderedBinary","arch","fs","tmpdir","MsgpackrEncoder","WeakLRUCache","EventEmitter","platform","compareKey","keyValueToBuffer","bufferToKeyValue","position","doPosition","getLastVersion","getLastTxnId","path","createRequire","v8AccelerationEnabled","setFlagsFromString"],"mappings":"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